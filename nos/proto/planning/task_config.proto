syntax = "proto2";

package hozon.planning;

import "proto/planning/speed_evaluator_config.proto";
import "proto/planning/ipopt_pos_optimize_smoother_config.proto";

//////////////////////////////////
// CreesDeciderConfig

message CreepDeciderConfig {
  // stop distance(m) to the creeping stop fence while creeping
  optional double stop_distance = 1 [default = 0.5];  // meter
  optional double speed_limit = 2 [default = 1.0];    // m/s
  // max distance(m) to the to the creeping stop fence
  // to be considered as a valid stop for creep
  optional double max_valid_stop_distance = 3 [default = 0.3];  // meter
  // min boundary t to ignore obstacles while creeping
  optional double min_boundary_t = 4 [default = 6.0];  // second
  // tolerance min_t & min_s to ignore obstacles which are moving
  // on same direction of ADC while creeping
  optional double ignore_max_st_min_t = 5 [default = 0.1];   // second
  optional double ignore_min_st_min_s = 6 [default = 15.0];  // meter
}

message GuideLineBoundsDeciderConfig {
  optional double guide_line_decider_resolution = 1 [default = 0.5];
  optional bool enable_debug_guide_line = 2 [default = false];
}

message PrecisePathBoundsDeciderConfig {
  optional double normal_obs_static_lat_buffer = 1 [default = 0.3];
  optional double normal_lane_solid_bound_buffer = 2 [default = 0.25];
  optional double special_obs_static_lat_buffer = 3;
  optional double special_lane_solid_bound_buffer = 4;
}

//////////////////////////////////
// ObstaclesDeciderConfig
message ObstaclesDeciderConfig {
  message AtSamplerConfig {
    repeated double sample_accel = 1;
    repeated double sample_time = 2;
    optional bool enable_debug = 3;
  }
  message SlSamplerConfig {
    optional double sample_relative_s = 1;
    optional double sample_relative_l = 2;
    optional bool enable_debug = 3;
  }
  message CostWeightShapeParam {
    optional double efficiency_cost_a = 1 [default = -1.2];
    optional double efficiency_cost_b = 2 [default = 2.0];
    optional double efficiency_cost_k = 3 [default = 1.0];

    optional double parallel_time_cost_a = 4 [default = 1.2];
    optional double parallel_time_cost_b = 5 [default = 1.2];
    optional double parallel_time_cost_k = 6 [default = 1.0];

    optional double safety_cost_a = 7 [default = -1.2];
    optional double safety_cost_b = 8 [default = 2.0];
    optional double safety_cost_k = 9 [default = 1.0];

    optional double lon_acc_comfort_cost_a = 10 [default = -1.2];
    optional double lon_acc_comfort_cost_b = 11 [default = -1.2];
    optional double lon_acc_comfort_cost_k = 12 [default = 1.0];
    optional double lon_jerk_comfort_cost_a = 13 [default = -1.2];
    optional double lon_jerk_comfort_cost_b = 14 [default = -1.2];
    optional double lon_jerk_comfort_cost_k = 15 [default = 1.0];

    optional double lat_offset_cost_a = 16 [default = 10.0];
    optional double lat_offset_cost_b = 17 [default = -2.0];
    optional double lat_offset_cost_k = 18 [default = 0.2];

    optional double lateral_stable_cost_a = 19 [default = 10.0];
    optional double lateral_stable_cost_b = 20 [default = -2.0];
    optional double lateral_stable_cost_k = 21 [default = -0.0];
    
    optional double longitudinal_stable_cost_a = 22 [default = 10.0];
    optional double longitudinal_stable_cost_b = 23 [default = -2.0];
    optional double longitudinal_stable_cost_k = 24 [default = -0.0];
  }

  optional AtSamplerConfig at_sampler_config = 1;
  optional SlSamplerConfig sl_sampler_config = 2;
  optional double sampling_interval = 3;
  optional CostWeightShapeParam cost_weight_shape_param = 4;
  optional bool enable_debug_avoid_alongside_decision = 5;
  optional double trajectory_time_resolution = 6;
  optional bool enable_avoid_alongside_decision = 7;
  optional bool ignore_obs_before_cipv = 8;
}

//////////////////////////////////
// AstarPathDeciderConfig
message AstarPathDeciderConfig {
  message AstarPathSigmoidFunctionShapeParam {
    optional double boundary_cost_a = 1 [default = -1.2];
    optional double boundary_cost_b = 2 [default = 2.0];
    optional double boundary_cost_k = 3 [default = 1.0];

    optional double reference_line_cost_a = 4 [default = 1.2];
    optional double reference_line_cost_k = 6 [default = 1.0];

    optional double dangerous_area_cost_a = 7 [default = -1.2];
    optional double dangerous_area_cost_b = 8 [default = 2.0];
    optional double dangerous_area_cost_k = 9 [default = 1.0];

    optional double static_obstacle_l_cost_a = 10 [default = -1.2];
    optional double static_obstacle_s_cost_a = 13 [default = -1.2];
    optional double static_obstacle_cost_k = 15 [default = 1.0];

    optional double dynamic_obstacle_cost_a = 16 [default = -1.2];
    optional double dynamic_obstacle_cost_b = 17 [default = 2.0];
    optional double dynamic_obstacle_cost_k = 18 [default = 1.0];

    optional double smooth_cost_d_phi_a = 19 [default = 10.0];
    optional double smooth_cost_d_phi_b = 20 [default = -2.0];
    optional double smooth_cost_d_phi_k = 21 [default = 0.2];
    optional double smooth_cost_dd_phi_a = 22 [default = 10.0];
    optional double smooth_cost_dd_phi_b = 23 [default = -2.0];
    optional double smooth_cost_dd_phi_k = 24 [default = -0.0];

    optional double similarity_cost_a = 25 [default = 1.2];
    optional double similarity_cost_b = 26 [default = -2.0];
    optional double similarity_cost_k = 27 [default = 1.0];
  }
  message  AstarGridSearchConfig {
    optional double lat_resolution = 1 [default = 0.2];
    optional double lon_resolution = 2 [default = 0.2];
    optional uint32 number_of_cross_lines = 3 [default = 10];
    optional AstarPathSigmoidFunctionShapeParam astar_path_sigmoid_function_shape_param = 8;
    optional double heuristic_cost_weight = 9 [default = 1.0];
    optional double dynamic_obstacle_delta_t = 10 [default = 2.0];
    optional double node_reasonable_buffer = 11 [default = 0.2];
    optional bool enable_search_debug = 12 [default = false];
    optional uint32 stable_static_count = 13 [default = 5];
    optional uint32 stable_nudge_dynamic_count = 14 [default = 5];
    optional double static_pedestrian_speed = 15 [default = 0.5];
    optional uint32 stable_dynamic_count = 16 [default = 15];
    optional double static_obstacle_safe_buff = 17 [default = 0.3];
  }

  optional AstarGridSearchConfig astar_grid_search_config = 1;
  optional bool enable_debug_astar_line = 2 [default = false];
  optional bool turn_off_astar_nudge = 3 [default = false];
}

//////////////////////////////////
// LaneChangeDeciderConfig

message LaneChangeDeciderConfig {
  optional bool enable_lane_change_urgency_check = 1;
  // True to enable prioritize change_lane reference line
  optional bool enable_prioritize_change_lane = 2 [default = false];
  // True to enable remove change_lane reference line");
  optional bool enable_remove_change_lane = 3 [default = false];
  // always allow the vehicle change lane. The vehicle may continue changing
  // lane
  optional bool reckless_change_lane = 4 [default = false];
  // not allowed to change lane this amount of time if just finished
  optional double change_lane_success_freeze_time = 5
      [default = 1.5];  // second
  // not allowed to change lane this amount of time if just failed
  optional double change_lane_fail_freeze_time = 6 [default = 1.0];  // second
  // adc and obstacle direction is the same, check safe time whether lane change is safe or not?
  optional double safe_time_on_same_direction = 7 [default = 3.0]; // second
  // adc needs min lane change safe time on same direction when lane change will be finished.
  optional double min_safe_time_on_same_direction = 8 [default = 2.0]; // second
  // adc and obstacle direction is same, check min safe distance to
  // forward obstacle whether lane change is safe or not?
  optional double forward_min_safe_distance_on_same_direction = 9 [default = 1.0];  // meter
  // adc and obstacle direction is same, check min safe distance to
  //  backward obstacle whether lane change is safe or not?
  optional double backward_min_safe_distance_same_direction = 10 [default = 10.0]; // meter
  // lane change safe time on opposite direction
  optional double safe_time_on_opposite_direction = 11 [default = 5.0]; // second
  // forward min safe distance on opposite direction
  optional double forward_min_safe_distance_on_opposite_direction = 12 [default = 50.0]; // meter
  // backward min safe distance on opposite direction
  optional double backward_min_safe_distance_on_opposite_direction = 13 [default = 1.0]; // meter
  // safe distance buffer
  optional double safe_distance_buffer = 14 [default = 0.5];// second
  // merging carriage reduce preview time
  optional double merging_carriage_reduce_preview_time = 15; // second
}

//////////////////////////////////
// LearningModelInferenceTaskConfig

message LearningModelInferenceTaskConfig {
  enum ModelType {
    CNN = 1;
    CNN_LSTM = 2;
  }
  optional ModelType model_type = 1;
  optional string cpu_model_file = 2;
  optional string gpu_model_file = 3;
  optional bool use_cuda = 4 [default = true];
  // delta_t depends on the model output, not a configurable value here
  optional double trajectory_delta_t = 5 [default = 0.2];  // second
  optional bool allow_empty_learning_based_data = 6 [default = false];
  optional bool allow_empty_output_trajectory = 7 [default = false];
}

//////////////////////////////////
// LearningModelInferenceTrajectoryTaskConfig

message LearningModelInferenceTrajectoryTaskConfig {
  optional double min_adc_future_trajectory_time_length = 1
      [default = 2.0];  // second
}

//////////////////////////////////
// Navi

message NaviObstacleDeciderConfig {
  optional double min_nudge_distance = 1 [default = 0.2];
  optional double max_nudge_distance = 2 [default = 1.2];
  optional double max_allow_nudge_speed = 3 [default = 16.667];
  optional double safe_distance = 4 [default = 0.2];
  optional double nudge_allow_tolerance = 5 [default = 0.05];
  optional uint32 cycles_number = 6 [default = 3];
  optional double judge_dis_coeff = 7 [default = 2.0];
  optional double basis_dis_value = 8 [default = 30.0];
  optional double lateral_velocity_value = 9 [default = 0.5];
  optional double speed_decider_detect_range = 10 [default = 1.0];
  optional uint32 max_keep_nudge_cycles = 11 [default = 100];
}

message NaviPathDeciderConfig {
  optional double min_path_length = 1 [default = 5];
  optional uint32 min_look_forward_time = 2 [default = 2];
  optional double max_keep_lane_distance = 3 [default = 0.8];
  optional double max_keep_lane_shift_y = 4 [default = 20.0];
  optional double min_keep_lane_offset = 5 [default = 15.0];
  optional double keep_lane_shift_compensation = 6 [default = 0.01];
  optional MoveDestLaneConfigTable move_dest_lane_config_talbe = 7;
  optional double move_dest_lane_compensation = 8 [default = 0.35];
  optional double max_kappa_threshold = 9 [default = 0.0];
  optional double kappa_move_dest_lane_compensation = 10 [default = 0.0];
  optional uint32 start_plan_point_from = 11 [default = 0];
}

message MoveDestLaneConfigTable {
  repeated ShiftConfig lateral_shift = 1;
}

message ShiftConfig {
  optional double max_speed = 1 [default = 4.16];
  optional double max_move_dest_lane_shift_y = 3 [default = 0.4];
}

message NaviSpeedDeciderConfig {
  optional double preferred_accel = 1 [default = 2.0];
  optional double preferred_decel = 2 [default = 2.0];
  optional double preferred_jerk = 3 [default = 2.0];
  optional double max_accel = 4 [default = 4.0];
  optional double max_decel = 5 [default = 5.0];
  optional double obstacle_buffer = 6 [default = 0.5];
  optional double safe_distance_base = 7 [default = 2.0];
  optional double safe_distance_ratio = 8 [default = 1.0];
  optional double following_accel_ratio = 9 [default = 0.5];
  optional double soft_centric_accel_limit = 10 [default = 1.2];
  optional double hard_centric_accel_limit = 11 [default = 1.5];
  optional double hard_speed_limit = 12 [default = 100.0];
  optional double hard_accel_limit = 13 [default = 10.0];
  optional bool enable_safe_path = 14 [default = true];
  optional bool enable_planning_start_point = 15 [default = true];
  optional bool enable_accel_auto_compensation = 16 [default = true];
  optional double kappa_preview = 17 [default = 0.0];
  optional double kappa_threshold = 18 [default = 0.0];
}

//////////////////////////////////
// PathAssessmentDeciderConfig

message PathAssessmentDeciderConfig {
  optional double back_to_inlane_extra_buffer = 1 [default = 0.1];
  optional double lane_change_back_to_inlane_extra_buffer = 2 [default = 0.75];
  optional double lane_keep_self_path_valid_normal_solid_buffer = 3 [default = 0.5];
  optional double lane_keep_self_path_valid_normal_dotted_buffer = 4 [default = 0.5];
  optional double lane_keep_self_path_valid_curved_solid_buffer = 5 [default = 0.5];
  optional double lane_keep_self_path_valid_curved_dotted_buffer = 6 [default = 0.5];
  optional double lane_keep_self_path_valid_start_judging_proportion = 7 [default = 0.5];
  optional bool path_valid_enable_all_drving_mode = 11 [default = true];
}

//////////////////////////////////
// PathBoundsDeciderConfig

message SteeringWheelAngleSpeedLimitConfig {
  optional bool enable_steering_wheel_angle_speed_limit = 1 [default = true];
  optional bool enable_full_effective_distance_of_curve = 2 [default = true];
  optional double effective_distance_of_curve = 3 [default = 20.0];
  optional double max_steering_protect_angle = 4 [default = 0.3490658504];
  optional double curvature_calculate_min_vehicle_speed = 5 [default = 2];
  optional double sampling_amplification_factor = 6 [default = 2.5];
  optional double cutoff_heading_of_vehicle_motion_curve = 7 [default = 1.5707963268];
  optional double max_steering_wheel_angle_line_buffer = 8 [default = 0.015];
  optional double max_steering_wheel_angle_opposite_line_buffer = 9 [default = 0.3];
  optional double steering_wheel_angle_line_protect_buffer = 10 [default = 0.3];
  optional double normal_steering_wheel_angle_l_enable_limit = 11 [default = 0.25];
  optional double normal_steering_wheel_angle_heading_enable_limit = 12 [default = 0.0];
  optional double curved_steering_wheel_angle_l_enable_limit = 13 [default = 0.25];
  optional double curved_steering_wheel_angle_heading_enable_limit = 14 [default = 0.0];
  optional double steer_limit_once_cross_line_value = 15 [default = 0.0];
  optional double enable_curvature_detection_steering_speed_limit_value = 16 [default = 0.0];
  optional bool enable_curvature_detection_steering_speed_limit = 17 [default = false];
}

message ObsTowingProcess {
  optional double static_obstacle_expect_towing_l = 1 [default = 1.0];
  optional double dynamic_obstacle_expect_towing_l = 2 [default = 0.75];
  optional double obstacle_avoid_bound_buffer = 3 [default = 0.0];
  optional double big_car_towing_min_process_length = 4 [default = 6.0];
  optional double towing_filter_process_distance_threshold = 5 [default = 5.0];
  optional double obstacle_towing_filter_error = 6 [default = 0.05];
  optional double big_car_towing_forward_prepare_time = 7 [default = 2.0];
  optional double big_car_towing_backward_prepare_time = 8 [default = 7.0];
  optional bool use_ttc_calculate_towing_prepare_distance = 9 [default = false];
  optional double big_car_towing_forward_prepare_distance = 10 [default = 15.0];
  optional double big_car_towing_backward_prepare_distance = 11 [default = 30.0];
  optional double static_obstacle_towing_forward_prepare_time = 12 [default = 3.0];
  optional double static_obstacle_towing_backward_prepare_time = 13 [default = 6.0];
  optional double static_obstacle_towing_prepare_distance_min_limit = 14 [default = 10.0];
  optional bool use_kinematic_corner_calculate_static_obstacle_bound = 15 [default = false];
  optional bool enable_static_obstacle_towing = 16 [default = true];
  optional bool use_decision_tags_set_towing_points = 17 [default = true];
  optional bool use_obstacle_decider_process_dynamic_obstacle = 18 [default = true];
}

message ObsTowingProcessConfig {
  optional ObsTowingProcess nnp_obs_towing_process = 1;
  optional ObsTowingProcess ncp_obs_towing_process = 2;
}

message DynamicObsProcessConfig {
  optional double dynamic_reserve_solution_space = 1 [default = 0.6];
  optional bool enable_dynamic_obs_dynamic_buffer_calculate = 2 [default = false];
  optional double obs_backward_filter_distance = 3 [default = 60.0];
  optional double obs_right_filter_distance = 4 [default = -5.0];
  optional double obs_left_filter_distance = 5 [default = 5.0];
  optional double obs_speed_filter_velocity = 6 [default = 0.5];
  optional double obs_big_car_filter_length = 7 [default = 6.5];
  optional double obs_big_car_filter_width = 8 [default = 2.5];
  optional double obs_big_car_filter_adc_speed = 9 [default = 9.0];
  optional double obs_boundary_evaluate_vehicle_time_length = 10 [default = 1.0];
  optional double obs_boundary_evaluate_other_time_length = 11 [default = 1.5];
  optional double obs_consider_filter_kappa = 12 [default = 0.009];
  optional double obs_consider_filter_l_buffer = 13 [default = 0.1];
  optional double default_half_lane_width = 14 [default = 2.0];
  optional double nudge_big_car_s_filter_distance_to_adc = 15 [default = 20.0];
  optional double both_sides_dynamic_obs_filter_distance = 16 [default = 30.0];
}

message LaneChangeProcessConfig {
  optional bool enable_segment_preview_time = 1 [default = false];
  optional bool enable_heuristic_prepare_lane_change = 2 [default = false];
  optional bool enable_heuristic_prepare_dl_limit = 3 [default = false];
  optional bool use_heuristic_lane_change_path = 4 [default = true];
  optional double lane_change_heuristic_line_buffer = 5 [default = 0.2];
  optional double lane_change_heuristic_opposite_line_buffer = 6 [default = 0.2];
  optional double lane_change_prepare_line_buffer = 7 [default = 0.2];
  optional double lane_change_prepare_opposite_line_buffer = 8 [default = 0.3];
  optional double lane_change_distance_preview_time = 9 [default = 3.0];
  optional double lane_change_distance_lower = 10 [default = 30.0];
  optional double lane_change_distance_upper = 11 [default = 80.0];
  optional double lane_change_prepare_opposite_line_protect_buffer = 12 [default = 0.2];
  optional double lane_change_prepare_opposite_line_protect_diff = 13 [default = 0.05];
  optional double lane_change_distance_preview_extend_time_ratio = 14 [default = 1.0];
  optional double lane_change_heuristic_protect_dl = 15 [default = 0.0025];
  optional double lane_change_heuristic_prepare_preview_time = 16 [default = 0.75];
  optional double lane_change_heuristic_prepare_distance_lower = 17 [default = 8.0];
  optional double lane_change_heuristic_prepare_distance_upper = 18 [default = 13.0];
  optional double lane_change_heuristic_prepare_l_limit = 19 [default = 2.0];
  optional double lane_change_heuristic_prepare_l_ratio = 20 [default = 0.8];
  optional double lane_change_heuristic_prepare_dl_limit = 21 [default = 0.025];
  optional LaneChangeSegmentConf lane_change_segment_conf = 22;
  optional double lane_change_default_width = 23 [default = 3.8];
}

message LaneBoundProcess {
  optional double path_default_lane_width = 1 [default = 4.0];
  optional double lane_bound_protect_buffer = 2 [default = 0.08];
  optional double lane_normal_solid_bound_buffer = 3 [default = 0.2];
  optional double lane_normal_dotted_bound_buffer = 4 [default = 0.1];
  optional double lane_curved_solid_bound_buffer = 5 [default = 0.2];
  optional double lane_curved_dotted_bound_buffer = 6 [default = 0.1];
  optional double lane_normal_virtual_bound_buffer = 7 [default = -0.3];
  optional double lane_curved_virtual_bound_buffer = 8 [default = -0.3];
  // lane type extend length(meters)
  optional bool enable_lane_solid_bound_forward_extend = 21 [default = true];
  optional bool enable_lane_solid_bound_backward_extend = 22 [default = true];
  optional double solid_line_forward_extend_length = 23 [default = 5.0];
  optional double solid_line_backward_extend_length = 24 [default = 5.0];
  optional double virtual_line_forward_extend_length = 25 [default = 5.0];
  optional double virtual_line_backward_extend_length = 26 [default = 5.0];
  optional int32 virtual_line_extend_split_num = 27 [default = 3];
  optional bool use_camera_lane_type = 28 [default = false];
  optional bool enable_normal_turn_line_is_solid = 29 [default = true];
}

message LaneBoundProcessConfig {
  optional LaneBoundProcess nnp_lane_bound_process = 1;
  optional LaneBoundProcess ncp_lane_bound_process = 2;
}

message ObstacleBufferProcessConfig {
  optional bool enable_static_obs_dynamic_buffer_calculate = 1 [default = false];
  optional double obs_static_lon_start_buffer = 2 [default = 3.5];
  optional double obs_static_lon_end_buffer = 3 [default = 3.0];
  optional double obs_static_lat_buffer = 4 [default = 0.3];
  optional double obs_dynamic_lon_start_buffer = 5 [default = 3.5];
  optional double obs_dynamic_lon_end_buffer = 6 [default = 3.0];
  optional double obs_dynamic_lat_buffer = 7 [default = 0.4];
  // obstacle bound buffer(meters)
  optional double obs_static_bound_buffer = 8 [default = 0.0];
  optional double obs_dynamic_bound_buffer = 9 [default = 0.0];
  optional double min_diff_left_and_right_bounds = 30 [default = 0.09];
  optional double min_lat_dis_adc_and_bound_buffer = 31 [default = 0.05];
  optional double stop_distance_buffer = 32 [default = 0.5];
}

message PullOverProcessConfig {
  optional bool is_pull_over = 1;
  // not search pull-over position if the destination is within this distance from ADC
  optional double pull_over_destination_to_adc_buffer = 2 [default = 25.0];
  // not search pull-over position if the destination is within this distance to path-end
  optional double pull_over_destination_to_pathend_buffer = 3 [default = 10.0];
  // disquality a pull-over position if the available path boundary's edge is
  // not within this distance from the road edge
  optional double pull_over_road_edge_buffer = 4 [default = 0.15];
  optional double pull_over_approach_lon_distance_adjust_factor = 5 [default = 1.5];
}

message PathBoundsDeciderConfig {
  optional bool is_lane_borrowing = 1;
  optional double adc_buffer_coeff = 2 [default = 1.0];
  optional bool is_extend_lane_bounds_to_include_adc = 3 [default = true];
  optional double path_end_distance_from_reference_end = 4 [default = 4.486];
  //filter path bound peaks
  optional double start_count_peaks_threshold = 5 [default = 0.09];
  optional double stop_count_peaks_threshold = 6 [default = 0.09];
  optional int32 peak_point_cnt = 7 [default = 5];
  // ADC path bound buffer(meters)
  optional double adc_lane_keep_buffer = 8 [default = 0.15];
  optional double adc_lane_change_buffer = 9 [default = 0.15];
  optional double adc_fallback_buffer = 10 [default = 0.5];
  // End point path bound shrink
  optional double shrink_distance = 11 [default = 10.0];
  optional double min_shrink_bound = 12 [default = 0.1];
  optional double shrink_end_distance = 13 [default = 2.0];
  // pull over process
  optional PullOverProcessConfig pull_over_process_config = 21;
  // obstacle buffer(meters)
  optional ObstacleBufferProcessConfig obstacle_buffer_process_config = 22;
  // lane bound buffer(meters)
  optional LaneBoundProcessConfig lane_bound_process_config = 23;
  // lane change bound process
  optional LaneChangeProcessConfig lane_change_process_config = 24;
  // dynamic obs path bound process
  optional DynamicObsProcessConfig dynamic_obs_process_config = 25;
  // dynamic obs towing process
  optional ObsTowingProcessConfig obs_towing_process_config = 26;
  // Steering wheel speed limit bound process
  optional SteeringWheelAngleSpeedLimitConfig steering_wheel_angle_speed_limit_config = 27;
}

message LaneChangeSegmentConf {
  repeated double speed_segment = 1;
  repeated double preview_time_segment = 2;
}

//////////////////////////////////
// PathDeciderConfig

message PathDeciderConfig {
  message AdcLBufferCalibrationTable {
    repeated double speed = 1;
    repeated double buffer = 2;
  }
  // buffer for static obstacles (meter)
  optional double static_obstacle_buffer = 1 [default = 0.3];
  optional double static_obstacle_stop_buffer_in_tba = 2 [default = 0.5];
  optional double freespace_stop_buffer = 3 [default = 0.5];
  optional AdcLBufferCalibrationTable adc_l_buffer_for_static_obstacle = 4;
  optional AdcLBufferCalibrationTable adc_l_buffer_for_stop_obstacle = 5;
}
//////////////////////////////////
// AvoidAlongsideDeciderConfig

message AvoidAlongsideDeciderConfig {
  optional bool enable_avoid_alongside = 1;
  optional double avoid_bigcar_adc_max_speed = 2 [default = 36.1];
  optional double avoid_bigcar_adc_min_speed = 3 [default = 16.6];
  // obstacle sift
  optional double avoid_obstacle_lateral_buffer = 4 [default = 0.3];
  optional double avoid_adc_min_safe_distance = 5 [default = 20.0];
  optional double avoid_adc_follow_time = 6 [default = 2.0];
  optional double avoid_adc_obs_ttc_lgt_distance = 7 [default = 1.0];
  // avoid bigcar threshold
  optional double avoid_obs_min_front_distance = 8 [default = 15.0];
  optional double avoid_adc_obs_max_ttc = 9 [default = 7.0];
  optional double avoid_adc_obs_min_ttc = 10 [default = 3.0];
  optional double avoid_obs_min_back_distance = 11 [default = 15.0];
  optional double avoid_adc_obs_ttc_hys = 12 [default = 8.0];
  optional double avoid_obs_min_label_time = 13 [default = 3.0];
  optional double avoid_obs_max_label_time = 14 [default = 15.0];
  // encounter bigcar of the other side during avoiding bigcar
  optional double avoid_other_obs_min_front_distance = 15 [default = 15.0];
  optional double avoid_other_obs_min_back_distance = 16 [default = 15.0];
  optional double avoid_adc_other_obs_ttc = 17 [default = 3.0];
  optional double avoid_obstacle_lateral_ratio = 18 [default = 0.1];
  optional double avoid_other_obs_lateral_ratio_for_stop = 19 [default = 0.05];
  optional double avoid_adc_follow_time_for_other_obs_danger = 20 [default = 1.0];
  optional double avoid_adc_other_obs_ttc_for_trigger = 21 [default = 10.0];
  optional double avoid_adc_lane_change_freeze_time = 22 [default = 1.0];
  // overtake bigcar whose speed is close to adc_speed
  optional double overtake_obs_max_distance_hys = 23 [default = 25.0];
  optional double overtake_obs_max_distance = 24 [default = 15.0];
  optional double overtake_obs_min_distance = 25 [default = 10.0];
  optional double avoid_obstacle_lateral_ratio_hys = 26 [default = 0.5];
}

//////////////////////////////////
// PathLaneBorrowDeciderConfig

message PathLaneBorrowDeciderConfig {
  optional bool allow_lane_borrowing = 1;
}

//////////////////////////////////
// PathLaneBorrowDeciderConfig

message NudgeDynamicObstacleDeciderConfig {
  optional bool allow_nudge_dynamic_obstacle = 1;
}

//////////////////////////////////
// PathReferenceDeciderConfig

message PathReferenceDeciderConfig {
  optional uint32 min_path_reference_length = 1 [default = 20];
  // learning model s weight
  optional double weight_x_ref_path_reference = 2;
}

//////////////////////////////////
// PathReuseDeciderConfig

message PathReuseDeciderConfig {
  optional bool reuse_path = 1;
}

//////////////////////////////////
// PiecewiseJerkNonlinearSpeedOptimizerConfig

message PiecewiseJerkNonlinearSpeedOptimizerConfig {
  // Driving comfort weights
  optional double acc_weight = 1 [default = 500.0];
  optional double jerk_weight = 2 [default = 100.0];
  optional double lat_acc_weight = 3 [default = 500.0];

  // Minimal traversal time weight
  optional double s_potential_weight = 4 [default = 10.0];

  // Preferred cruising speed weight
  optional double ref_v_weight = 5 [default = 10.0];

  // Optional reference speed profile weight
  optional double ref_s_weight = 6 [default = 10.0];

  // Task specific end point weight
  optional double end_s_weight = 7 [default = 10.0];
  optional double end_v_weight = 8 [default = 10.0];
  optional double end_a_weight = 9 [default = 10.0];

  // soft safety boundary constraint violation weight
  optional double soft_s_bound_weight = 10 [default = 10.0];

  // Solver settings
  optional bool use_warm_start = 100 [default = true];
}

message PiecewiseJerkOSQPConfig {
  optional bool verbose = 1 [default = false];
  optional double eps_abs = 2 [default = 5e-4];
  optional double eps_rel = 3 [default = 5e-4];
  optional double eps_prim_inf = 4 [default = 5e-4];
  optional double eps_dual_inf = 5 [default = 5e-4];
  optional bool scaled_termination = 6 [default = false];
  optional bool adaptive_rho = 7 [default = true];
  optional bool polish = 8 [default = true];
  optional int32 polish_refine_iter = 9 [default = 20];
  optional int32 max_iter = 10 [default = 500];
  optional int32 adaptive_rho_interval = 11 [default = 25];
  optional double alpha = 12 [default = 1.6];
  optional double time_limit = 13 [default = 0.0];
}

//////////////////////////////////
// PiecewiseJerkPathOptimizerConfig

message PiecewiseJerkPathOptimizerConfig {
  enum OptimizerMethod {
    OSQP_SMOOTHER = 0;
    IPOPT_SMOOTHER = 1;
  };
  optional OptimizerMethod optimizer_method = 1;
  optional PiecewiseJerkOSQPConfig osqp_config = 2;
  optional PiecewiseJerkOSQPConfig osqp_fallback_config = 3;
  optional PiecewiseJerkPathWeights default_path_weight_config = 4;
  optional PiecewiseJerkPathWeights lane_change_path_weight_config = 5;
  optional LateralBoundsSegmentConfig lateral_bounds_segment_config = 6;
  optional PiecewiseJerkPathWeights perception_path_config = 7;
  optional PiecewiseJerkPathWeights perception_lane_change_path_config = 8;
  optional IpoptPosOptimizeSmootherConfig ipopt_config = 9;
  optional AMatrixConfig a_matrix_config = 10;
  optional PMatrixConfig p_matrix_config = 11;
  optional QMatrixConfig q_matrix_config = 12;
  optional double path_reference_l_weight = 16 [default = 0.0];
  optional int32 use_fallback_osqp_point_num = 17 [default = 30];
  optional double min_speed_for_curvature = 18 [default = 5.0];
  optional double jerk_bound_forward_ignore_time = 19 [default = 1.0];
  optional double jerk_bound_forward_min_distance = 20 [default = 15.0];
  optional bool enable_jerk_bound_dynamic_forward_length = 21 [default = false];
  optional double max_lateral_acc = 22 [default = 2.0];
  optional double max_dl_ratio = 23 [default = 1.1];
  optional double max_ddl_ratio = 24 [default = 1.0];
}

message AMatrixConfig {
  optional bool enable_collision_constraint = 1 [default = false];
  optional bool enable_curvature_process = 2 [default = false];
  optional bool enable_curvature_derivative_process = 3 [default = false];
  optional double max_curvature = 6 [default = 0.2];
  optional double max_curvature_derivative = 7 [default = 0.1];
}

message PMatrixConfig {
  optional double coef_init_kappa_l_constraint_weight = 1 [default = 40000.0];
  optional double coef_init_kappa_l_unconstrained_weight = 2 [default = 0.0];
  optional double weight_soft_l_constraint = 3 [default = 1e7];
  optional bool enable_ddx_dynamic_weight = 4 [default = false];
  optional bool enable_dddx_dynamic_weight = 5 [default = false];
  optional double dynamic_weight_lower_speed_weight = 6 [default = 0.85];
  optional double dynamic_weight_min_longitudinal_speed = 7 [default = 3.0];
}

message QMatrixConfig {
  optional bool enable_q_matrix_ddl_offset = 1 [default = false];
  optional bool enable_q_matrix_start_end_state_offset = 2 [default = false];
}

message LateralBoundsSegmentConfig {
  repeated double path_init_v_segment = 1;
  repeated double dddl_bound_segment = 2;
}

message PiecewiseJerkPathWeights {
  optional double l_weight = 1 [default = 1.0];
  optional double dl_weight = 2 [default = 100.0];
  optional double ddl_weight = 3 [default = 1000.0];
  optional double dddl_weight = 4 [default = 10000.0];
  optional double towing_ref_weight = 5 [default = 0.0];
  optional bool enable_path_weight_segment = 9 [default = false];
  optional PathSegmentConf path_weight_segment_conf = 10;
  optional double ddl_offset_weight = 11 [default = 0.0];
}

message PathSegmentConf {
  repeated double speed_segment = 1;
  repeated double l_weight_segment = 2;
  repeated double dl_weight_segment = 3;
  repeated double ddl_weight_segment = 4;
  repeated double dddl_weight_segment = 5;
}

//////////////////////////////////
// PiecewiseJerkSpeedOptimizerConfig

message PiecewiseJerkSpeedOptimizerConfig {
  optional PiecewiseJerkOSQPConfig osqp_config = 1;
  optional double acc_weight = 2 [default = 1.0];
  optional double jerk_weight = 3 [default = 10.0];
  optional double kappa_penalty_weight = 4 [default = 1000.0];
  optional double ref_s_weight = 5 [default = 10.0];
  optional double ref_v_weight = 6 [default = 10.0];
}

//////////////////////////////////
// RuleBasedStopDeciderConfig

message RuleBasedStopDeciderConfig {
  optional double max_adc_stop_speed = 1 [default = 0.3];
  optional double max_valid_stop_distance = 2 [default = 0.5];
  optional double search_beam_length = 3 [default = 5.0];
  optional double search_beam_radius_intensity = 4 [default = 0.08];
  optional double search_range = 5 [default = 3.14];
  optional double is_block_angle_threshold = 6 [default = 1.57];

  optional double approach_distance_for_lane_change = 10 [default = 200.0];
  optional double urgent_distance_for_lane_change = 11 [default = 50.0];
  optional double stop_distance_from_path_end = 12 [default = 5.0];
}

//////////////////////////////////
// SpeedBoundsDeciderConfig

message SpeedBoundsDeciderConfig {

  message MaxSteerAngleSpeedCalibrationInfo {
    optional double speed = 1 [default = 0.0];
    optional double max_steer_angle_speed = 2 [default = 0.0];
  }

  message MaxSteerAngleSpeedCalibrationTable {
    repeated MaxSteerAngleSpeedCalibrationInfo calibration_info = 1;
  }

  message MaxLateralAccCalbration {
    optional double radius = 2 [default = 10.0];
    optional double max_lateral_acc = 1 [default = 0.45];
  }

  message MaxLateralAccCalbrationTable {
    repeated MaxLateralAccCalbration calibration_info = 1;
  }

  optional double total_time = 1 [default = 7.0];
  optional double boundary_buffer = 2 [default = 0.1];
  optional double max_centric_acceleration_limit = 3 [default = 2.0];
  optional double minimal_kappa = 4 [default = 0.00001];
  optional double point_extension = 5 [default = 1.0];
  optional double lowest_speed = 6 [default = 2.5];
  optional double collision_safety_range = 7 [default = 1.0];
  optional double static_obs_nudge_speed_ratio = 8;
  optional double dynamic_obs_nudge_speed_ratio = 9;
  optional double curvature_preview_distance = 10 [default = 10.0];
  optional double freespace_speed_limit_1st_distance = 11 [default = 0.3];
  optional double freespace_speed_limit_1st_speed = 12 [default = 0.3];
  optional double freespace_speed_limit_2nd_distance = 13 [default = 0.6];
  optional double freespace_speed_limit_2nd_speed = 14 [default = 0.5];
  optional double over_speed_ratio = 15 [default = 0.0];
  optional double max_over_speed = 16 [default = 0.0];
  optional double pedestrian_speed_limit_s_unit = 17 [default = 0.02];
  optional double pedestrian_speed_limit_l_unit = 18 [default = 0.05];
  optional MaxSteerAngleSpeedCalibrationTable max_steer_angle_speed_calibration_table = 19;
  optional uint32 cruise_speed_stable_cnt = 20 [default = 3];
  optional MaxLateralAccCalbrationTable max_lateral_acc_calbration_table_reverse = 21;
  optional double pedestrian_speed_limit_ratio = 22 [default = 5.0];
  optional double user_max_speed = 23 [default = 36.111];
  optional MaxLateralAccCalbrationTable max_lateral_acc_calbration_table_forward = 24;
  optional double min_freespace_limit_speed_forward = 25;
  optional double min_freespace_limit_speed_reverse = 26;
}

//////////////////////////////////
// SpeedHeuristicOptimizerConfig

message SpeedHeuristicOptimizerConfig {
  optional DpStSpeedOptimizerConfig default_speed_config = 1;
  optional DpStSpeedOptimizerConfig lane_change_speed_config = 2;
}

message DpStSpeedOptimizerConfig {
  optional double unit_t = 1 [default = 1.0];
  optional int32 dense_dimension_s = 2 [default = 41];
  optional double dense_unit_s = 3 [default = 0.5];
  optional double sparse_unit_s = 4 [default = 1.0];

  optional double speed_weight = 10 [default = 0.0];
  optional double accel_weight = 11 [default = 10.0];
  optional double jerk_weight = 12 [default = 10.0];
  optional double obstacle_weight = 13 [default = 1.0];
  optional double reference_weight = 14 [default = 0.0];
  optional double go_down_buffer = 15 [default = 5.0];
  optional double go_up_buffer = 16 [default = 5.0];

  // obstacle cost config
  optional double default_obstacle_cost = 20 [default = 1e10];

  // speed cost config
  optional double default_speed_cost = 31 [default = 1.0];
  optional double exceed_speed_penalty = 32 [default = 10.0];
  optional double low_speed_penalty = 33 [default = 2.5];
  optional double reference_speed_penalty = 34 [default = 1.0];
  optional double keep_clear_low_speed_penalty = 35 [default = 10.0];

  // accel cost config
  optional double accel_penalty = 40 [default = 2.0];
  optional double decel_penalty = 41 [default = 2.0];

  // jerk cost config
  optional double positive_jerk_coeff = 50 [default = 1.0];
  optional double negative_jerk_coeff = 51 [default = 300.0];

  // other constraint
  optional double max_acceleration = 60 [default = 4.5];
  optional double max_deceleration = 61 [default = -4.5];

  // buffer
  optional double safe_time_buffer = 70 [default = 3.0];
  optional double safe_distance = 71 [default = 20.0];

  // spatial potential cost config for minimal time traversal
  optional double spatial_potential_penalty = 80 [default = 1.0];

  optional bool is_lane_changing = 81 [default = false];

  optional double hexagon_cost_big_car_ratio_of_car_length = 82 [default = 2];
  optional double hexagon_cost_big_car_p1_x_buffer = 83 [default = 2];
  optional double hexagon_cost_big_car_p1_y_buffer = 84 [default = 6];
  optional double hexagon_cost_big_car_p6_x_buffer = 85 [default = 2];
  optional double  hexagon_cost_sigmoid_a = 86 [default = 1.4];
  optional double hexagon_cost_sigmoid_b = 87 [default = 3.6];
  optional double hexagon_cost_sigmoid_max_ratio = 88 [default = 0.8];
  optional double  hexagon_cost_sigmoid_factor = 89 [default = 10];
}

//////////////////////////////////
// STBoundsDeciderConfig

message STBoundsDeciderConfig {
  optional double total_time = 1 [default = 7.0];
  optional double min_distance_for_consider_rear_obstacle = 2 [default = 10.0];
  optional double time_distance_for_consider_rear_obstacle = 3 [default = 1.0];
}

//////////////////////////////////
// SpeedDataOptimizerConfig
message SpeedDataOptimizerConfig {
  // cache config
  optional SpeedCacheConfig speed_cache_config = 1;

  // speed scenario manager config
  optional SpeedScenarioManagerConfig speed_scenario_manager_config = 6;

  // speed data generator config
  optional SpeedDataGeneratorConfig forward_speed_data_generator_config = 7;
  optional SpeedDataGeneratorConfig reverse_speed_data_generator_config = 8;
}

message GuideLinePathOptimizerConfig {
  message OsqpPathSmootherConfig {
    optional bool verbose = 1 [default = false];
    optional double eps_abs = 2 [default = 5e-4];
    optional double eps_rel = 3 [default = 5e-4];
    optional double eps_prim_inf = 4 [default = 5e-4];
    optional double eps_dual_inf = 5 [default = 5e-4];
    optional bool scaled_termination = 6 [default = false];
    optional bool adaptive_rho = 7 [default = true];
    optional bool polish = 8 [default = true];
    optional int32 polish_refine_iter = 9 [default = 20];
    optional int32 max_iter = 10 [default = 500];
    optional int32 adaptive_rho_interval = 11 [default = 25];
    optional double alpha = 12 [default = 1.6];
    optional double time_limit = 13 [default = 0.0];
    optional double dl_bound = 14 [default = 50];
    optional double ddl_bound = 15 [default = 50];
    optional double dddl_bound = 16 [default = 10];
    optional double l_weight = 21 [default = 1.0];
    optional double dl_weight = 22 [default = 100.0];
    optional double ddl_weight = 23 [default = 1000.0];
    optional double dddl_weight = 24 [default = 10000.0];
    optional AMatrixConfig a_matrix_config = 25;
  }
  optional bool enable_ipopt_smoother = 1;
  optional IpoptPosOptimizeSmootherConfig ipopt_path_smoother = 2;
  optional OsqpPathSmootherConfig osqp_path_smoother = 3;
  optional OsqpPathSmootherConfig osqp_path_smoother_backward = 4;
}

message SpeedDeciderConfig {
  optional double fallback_accel_threshold = 1 [default = -4.0];
  optional double fallback_decel_threshold = 2 [default = -4.0];
}
