// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file lat.cpp
 * This source file contains the implementation of the described types in the IDL file.
 *
 * This file was generated by the tool fastddsgen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "lat.h"
#include "latTypeObject.h"

#include <fastcdr/Cdr.h>


#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>


Lat::Lat()
{

    // Just to register all known types
    registerlatTypes();
}

Lat::~Lat()
{
}

Lat::Lat(
        const Lat& x)
{
    m_timestamp_us = x.m_timestamp_us;
    m_seq = x.m_seq;
}

Lat::Lat(
        Lat&& x) noexcept
{
    m_timestamp_us = x.m_timestamp_us;
    m_seq = x.m_seq;
}

Lat& Lat::operator =(
        const Lat& x)
{

    m_timestamp_us = x.m_timestamp_us;
    m_seq = x.m_seq;

    return *this;
}

Lat& Lat::operator =(
        Lat&& x) noexcept
{

    m_timestamp_us = x.m_timestamp_us;
    m_seq = x.m_seq;

    return *this;
}

bool Lat::operator ==(
        const Lat& x) const
{
    return (m_timestamp_us == x.m_timestamp_us &&
           m_seq == x.m_seq);
}

bool Lat::operator !=(
        const Lat& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member timestamp_us
 * @param _timestamp_us New value for member timestamp_us
 */
void Lat::timestamp_us(
        double _timestamp_us)
{
    m_timestamp_us = _timestamp_us;
}

/*!
 * @brief This function returns the value of member timestamp_us
 * @return Value of member timestamp_us
 */
double Lat::timestamp_us() const
{
    return m_timestamp_us;
}

/*!
 * @brief This function returns a reference to member timestamp_us
 * @return Reference to member timestamp_us
 */
double& Lat::timestamp_us()
{
    return m_timestamp_us;
}


/*!
 * @brief This function sets a value in member seq
 * @param _seq New value for member seq
 */
void Lat::seq(
        int32_t _seq)
{
    m_seq = _seq;
}

/*!
 * @brief This function returns the value of member seq
 * @return Value of member seq
 */
int32_t Lat::seq() const
{
    return m_seq;
}

/*!
 * @brief This function returns a reference to member seq
 * @return Reference to member seq
 */
int32_t& Lat::seq()
{
    return m_seq;
}


LatVar::LatVar()
{

    // Just to register all known types
    registerlatTypes();
}

LatVar::~LatVar()
{
}

LatVar::LatVar(
        const LatVar& x)
{
    m_lat = x.m_lat;
    m_payload = x.m_payload;
}

LatVar::LatVar(
        LatVar&& x) noexcept
{
    m_lat = std::move(x.m_lat);
    m_payload = std::move(x.m_payload);
}

LatVar& LatVar::operator =(
        const LatVar& x)
{

    m_lat = x.m_lat;
    m_payload = x.m_payload;

    return *this;
}

LatVar& LatVar::operator =(
        LatVar&& x) noexcept
{

    m_lat = std::move(x.m_lat);
    m_payload = std::move(x.m_payload);

    return *this;
}

bool LatVar::operator ==(
        const LatVar& x) const
{
    return (m_lat == x.m_lat &&
           m_payload == x.m_payload);
}

bool LatVar::operator !=(
        const LatVar& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member lat
 * @param _lat New value to be copied in member lat
 */
void LatVar::lat(
        const Lat& _lat)
{
    m_lat = _lat;
}

/*!
 * @brief This function moves the value in member lat
 * @param _lat New value to be moved in member lat
 */
void LatVar::lat(
        Lat&& _lat)
{
    m_lat = std::move(_lat);
}

/*!
 * @brief This function returns a constant reference to member lat
 * @return Constant reference to member lat
 */
const Lat& LatVar::lat() const
{
    return m_lat;
}

/*!
 * @brief This function returns a reference to member lat
 * @return Reference to member lat
 */
Lat& LatVar::lat()
{
    return m_lat;
}


/*!
 * @brief This function copies the value in member payload
 * @param _payload New value to be copied in member payload
 */
void LatVar::payload(
        const std::vector<uint8_t>& _payload)
{
    m_payload = _payload;
}

/*!
 * @brief This function moves the value in member payload
 * @param _payload New value to be moved in member payload
 */
void LatVar::payload(
        std::vector<uint8_t>&& _payload)
{
    m_payload = std::move(_payload);
}

/*!
 * @brief This function returns a constant reference to member payload
 * @return Constant reference to member payload
 */
const std::vector<uint8_t>& LatVar::payload() const
{
    return m_payload;
}

/*!
 * @brief This function returns a reference to member payload
 * @return Reference to member payload
 */
std::vector<uint8_t>& LatVar::payload()
{
    return m_payload;
}


Lat1K::Lat1K()
{

    // Just to register all known types
    registerlatTypes();
}

Lat1K::~Lat1K()
{
}

Lat1K::Lat1K(
        const Lat1K& x)
{
    m_lat = x.m_lat;
    m_payload = x.m_payload;
}

Lat1K::Lat1K(
        Lat1K&& x) noexcept
{
    m_lat = std::move(x.m_lat);
    m_payload = std::move(x.m_payload);
}

Lat1K& Lat1K::operator =(
        const Lat1K& x)
{

    m_lat = x.m_lat;
    m_payload = x.m_payload;

    return *this;
}

Lat1K& Lat1K::operator =(
        Lat1K&& x) noexcept
{

    m_lat = std::move(x.m_lat);
    m_payload = std::move(x.m_payload);

    return *this;
}

bool Lat1K::operator ==(
        const Lat1K& x) const
{
    return (m_lat == x.m_lat &&
           m_payload == x.m_payload);
}

bool Lat1K::operator !=(
        const Lat1K& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member lat
 * @param _lat New value to be copied in member lat
 */
void Lat1K::lat(
        const Lat& _lat)
{
    m_lat = _lat;
}

/*!
 * @brief This function moves the value in member lat
 * @param _lat New value to be moved in member lat
 */
void Lat1K::lat(
        Lat&& _lat)
{
    m_lat = std::move(_lat);
}

/*!
 * @brief This function returns a constant reference to member lat
 * @return Constant reference to member lat
 */
const Lat& Lat1K::lat() const
{
    return m_lat;
}

/*!
 * @brief This function returns a reference to member lat
 * @return Reference to member lat
 */
Lat& Lat1K::lat()
{
    return m_lat;
}


/*!
 * @brief This function copies the value in member payload
 * @param _payload New value to be copied in member payload
 */
void Lat1K::payload(
        const std::array<uint8_t, 1024>& _payload)
{
    m_payload = _payload;
}

/*!
 * @brief This function moves the value in member payload
 * @param _payload New value to be moved in member payload
 */
void Lat1K::payload(
        std::array<uint8_t, 1024>&& _payload)
{
    m_payload = std::move(_payload);
}

/*!
 * @brief This function returns a constant reference to member payload
 * @return Constant reference to member payload
 */
const std::array<uint8_t, 1024>& Lat1K::payload() const
{
    return m_payload;
}

/*!
 * @brief This function returns a reference to member payload
 * @return Reference to member payload
 */
std::array<uint8_t, 1024>& Lat1K::payload()
{
    return m_payload;
}


Lat10K::Lat10K()
{

    // Just to register all known types
    registerlatTypes();
}

Lat10K::~Lat10K()
{
}

Lat10K::Lat10K(
        const Lat10K& x)
{
    m_lat = x.m_lat;
    m_payload = x.m_payload;
}

Lat10K::Lat10K(
        Lat10K&& x) noexcept
{
    m_lat = std::move(x.m_lat);
    m_payload = std::move(x.m_payload);
}

Lat10K& Lat10K::operator =(
        const Lat10K& x)
{

    m_lat = x.m_lat;
    m_payload = x.m_payload;

    return *this;
}

Lat10K& Lat10K::operator =(
        Lat10K&& x) noexcept
{

    m_lat = std::move(x.m_lat);
    m_payload = std::move(x.m_payload);

    return *this;
}

bool Lat10K::operator ==(
        const Lat10K& x) const
{
    return (m_lat == x.m_lat &&
           m_payload == x.m_payload);
}

bool Lat10K::operator !=(
        const Lat10K& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member lat
 * @param _lat New value to be copied in member lat
 */
void Lat10K::lat(
        const Lat& _lat)
{
    m_lat = _lat;
}

/*!
 * @brief This function moves the value in member lat
 * @param _lat New value to be moved in member lat
 */
void Lat10K::lat(
        Lat&& _lat)
{
    m_lat = std::move(_lat);
}

/*!
 * @brief This function returns a constant reference to member lat
 * @return Constant reference to member lat
 */
const Lat& Lat10K::lat() const
{
    return m_lat;
}

/*!
 * @brief This function returns a reference to member lat
 * @return Reference to member lat
 */
Lat& Lat10K::lat()
{
    return m_lat;
}


/*!
 * @brief This function copies the value in member payload
 * @param _payload New value to be copied in member payload
 */
void Lat10K::payload(
        const std::array<uint8_t, 10240>& _payload)
{
    m_payload = _payload;
}

/*!
 * @brief This function moves the value in member payload
 * @param _payload New value to be moved in member payload
 */
void Lat10K::payload(
        std::array<uint8_t, 10240>&& _payload)
{
    m_payload = std::move(_payload);
}

/*!
 * @brief This function returns a constant reference to member payload
 * @return Constant reference to member payload
 */
const std::array<uint8_t, 10240>& Lat10K::payload() const
{
    return m_payload;
}

/*!
 * @brief This function returns a reference to member payload
 * @return Reference to member payload
 */
std::array<uint8_t, 10240>& Lat10K::payload()
{
    return m_payload;
}


Lat100K::Lat100K()
{

    // Just to register all known types
    registerlatTypes();
}

Lat100K::~Lat100K()
{
}

Lat100K::Lat100K(
        const Lat100K& x)
{
    m_lat = x.m_lat;
    m_payload = x.m_payload;
}

Lat100K::Lat100K(
        Lat100K&& x) noexcept
{
    m_lat = std::move(x.m_lat);
    m_payload = std::move(x.m_payload);
}

Lat100K& Lat100K::operator =(
        const Lat100K& x)
{

    m_lat = x.m_lat;
    m_payload = x.m_payload;

    return *this;
}

Lat100K& Lat100K::operator =(
        Lat100K&& x) noexcept
{

    m_lat = std::move(x.m_lat);
    m_payload = std::move(x.m_payload);

    return *this;
}

bool Lat100K::operator ==(
        const Lat100K& x) const
{
    return (m_lat == x.m_lat &&
           m_payload == x.m_payload);
}

bool Lat100K::operator !=(
        const Lat100K& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member lat
 * @param _lat New value to be copied in member lat
 */
void Lat100K::lat(
        const Lat& _lat)
{
    m_lat = _lat;
}

/*!
 * @brief This function moves the value in member lat
 * @param _lat New value to be moved in member lat
 */
void Lat100K::lat(
        Lat&& _lat)
{
    m_lat = std::move(_lat);
}

/*!
 * @brief This function returns a constant reference to member lat
 * @return Constant reference to member lat
 */
const Lat& Lat100K::lat() const
{
    return m_lat;
}

/*!
 * @brief This function returns a reference to member lat
 * @return Reference to member lat
 */
Lat& Lat100K::lat()
{
    return m_lat;
}


/*!
 * @brief This function copies the value in member payload
 * @param _payload New value to be copied in member payload
 */
void Lat100K::payload(
        const std::array<uint8_t, 102400>& _payload)
{
    m_payload = _payload;
}

/*!
 * @brief This function moves the value in member payload
 * @param _payload New value to be moved in member payload
 */
void Lat100K::payload(
        std::array<uint8_t, 102400>&& _payload)
{
    m_payload = std::move(_payload);
}

/*!
 * @brief This function returns a constant reference to member payload
 * @return Constant reference to member payload
 */
const std::array<uint8_t, 102400>& Lat100K::payload() const
{
    return m_payload;
}

/*!
 * @brief This function returns a reference to member payload
 * @return Reference to member payload
 */
std::array<uint8_t, 102400>& Lat100K::payload()
{
    return m_payload;
}


Lat200K::Lat200K()
{

    // Just to register all known types
    registerlatTypes();
}

Lat200K::~Lat200K()
{
}

Lat200K::Lat200K(
        const Lat200K& x)
{
    m_lat = x.m_lat;
    m_payload = x.m_payload;
}

Lat200K::Lat200K(
        Lat200K&& x) noexcept
{
    m_lat = std::move(x.m_lat);
    m_payload = std::move(x.m_payload);
}

Lat200K& Lat200K::operator =(
        const Lat200K& x)
{

    m_lat = x.m_lat;
    m_payload = x.m_payload;

    return *this;
}

Lat200K& Lat200K::operator =(
        Lat200K&& x) noexcept
{

    m_lat = std::move(x.m_lat);
    m_payload = std::move(x.m_payload);

    return *this;
}

bool Lat200K::operator ==(
        const Lat200K& x) const
{
    return (m_lat == x.m_lat &&
           m_payload == x.m_payload);
}

bool Lat200K::operator !=(
        const Lat200K& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member lat
 * @param _lat New value to be copied in member lat
 */
void Lat200K::lat(
        const Lat& _lat)
{
    m_lat = _lat;
}

/*!
 * @brief This function moves the value in member lat
 * @param _lat New value to be moved in member lat
 */
void Lat200K::lat(
        Lat&& _lat)
{
    m_lat = std::move(_lat);
}

/*!
 * @brief This function returns a constant reference to member lat
 * @return Constant reference to member lat
 */
const Lat& Lat200K::lat() const
{
    return m_lat;
}

/*!
 * @brief This function returns a reference to member lat
 * @return Reference to member lat
 */
Lat& Lat200K::lat()
{
    return m_lat;
}


/*!
 * @brief This function copies the value in member payload
 * @param _payload New value to be copied in member payload
 */
void Lat200K::payload(
        const std::array<uint8_t, 204800>& _payload)
{
    m_payload = _payload;
}

/*!
 * @brief This function moves the value in member payload
 * @param _payload New value to be moved in member payload
 */
void Lat200K::payload(
        std::array<uint8_t, 204800>&& _payload)
{
    m_payload = std::move(_payload);
}

/*!
 * @brief This function returns a constant reference to member payload
 * @return Constant reference to member payload
 */
const std::array<uint8_t, 204800>& Lat200K::payload() const
{
    return m_payload;
}

/*!
 * @brief This function returns a reference to member payload
 * @return Reference to member payload
 */
std::array<uint8_t, 204800>& Lat200K::payload()
{
    return m_payload;
}


Lat500K::Lat500K()
{

    // Just to register all known types
    registerlatTypes();
}

Lat500K::~Lat500K()
{
}

Lat500K::Lat500K(
        const Lat500K& x)
{
    m_lat = x.m_lat;
    m_payload = x.m_payload;
}

Lat500K::Lat500K(
        Lat500K&& x) noexcept
{
    m_lat = std::move(x.m_lat);
    m_payload = std::move(x.m_payload);
}

Lat500K& Lat500K::operator =(
        const Lat500K& x)
{

    m_lat = x.m_lat;
    m_payload = x.m_payload;

    return *this;
}

Lat500K& Lat500K::operator =(
        Lat500K&& x) noexcept
{

    m_lat = std::move(x.m_lat);
    m_payload = std::move(x.m_payload);

    return *this;
}

bool Lat500K::operator ==(
        const Lat500K& x) const
{
    return (m_lat == x.m_lat &&
           m_payload == x.m_payload);
}

bool Lat500K::operator !=(
        const Lat500K& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member lat
 * @param _lat New value to be copied in member lat
 */
void Lat500K::lat(
        const Lat& _lat)
{
    m_lat = _lat;
}

/*!
 * @brief This function moves the value in member lat
 * @param _lat New value to be moved in member lat
 */
void Lat500K::lat(
        Lat&& _lat)
{
    m_lat = std::move(_lat);
}

/*!
 * @brief This function returns a constant reference to member lat
 * @return Constant reference to member lat
 */
const Lat& Lat500K::lat() const
{
    return m_lat;
}

/*!
 * @brief This function returns a reference to member lat
 * @return Reference to member lat
 */
Lat& Lat500K::lat()
{
    return m_lat;
}


/*!
 * @brief This function copies the value in member payload
 * @param _payload New value to be copied in member payload
 */
void Lat500K::payload(
        const std::array<uint8_t, 512000>& _payload)
{
    m_payload = _payload;
}

/*!
 * @brief This function moves the value in member payload
 * @param _payload New value to be moved in member payload
 */
void Lat500K::payload(
        std::array<uint8_t, 512000>&& _payload)
{
    m_payload = std::move(_payload);
}

/*!
 * @brief This function returns a constant reference to member payload
 * @return Constant reference to member payload
 */
const std::array<uint8_t, 512000>& Lat500K::payload() const
{
    return m_payload;
}

/*!
 * @brief This function returns a reference to member payload
 * @return Reference to member payload
 */
std::array<uint8_t, 512000>& Lat500K::payload()
{
    return m_payload;
}


Lat1000K::Lat1000K()
{

    // Just to register all known types
    registerlatTypes();
}

Lat1000K::~Lat1000K()
{
}

Lat1000K::Lat1000K(
        const Lat1000K& x)
{
    m_lat = x.m_lat;
    m_payload = x.m_payload;
}

Lat1000K::Lat1000K(
        Lat1000K&& x) noexcept
{
    m_lat = std::move(x.m_lat);
    m_payload = std::move(x.m_payload);
}

Lat1000K& Lat1000K::operator =(
        const Lat1000K& x)
{

    m_lat = x.m_lat;
    m_payload = x.m_payload;

    return *this;
}

Lat1000K& Lat1000K::operator =(
        Lat1000K&& x) noexcept
{

    m_lat = std::move(x.m_lat);
    m_payload = std::move(x.m_payload);

    return *this;
}

bool Lat1000K::operator ==(
        const Lat1000K& x) const
{
    return (m_lat == x.m_lat &&
           m_payload == x.m_payload);
}

bool Lat1000K::operator !=(
        const Lat1000K& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member lat
 * @param _lat New value to be copied in member lat
 */
void Lat1000K::lat(
        const Lat& _lat)
{
    m_lat = _lat;
}

/*!
 * @brief This function moves the value in member lat
 * @param _lat New value to be moved in member lat
 */
void Lat1000K::lat(
        Lat&& _lat)
{
    m_lat = std::move(_lat);
}

/*!
 * @brief This function returns a constant reference to member lat
 * @return Constant reference to member lat
 */
const Lat& Lat1000K::lat() const
{
    return m_lat;
}

/*!
 * @brief This function returns a reference to member lat
 * @return Reference to member lat
 */
Lat& Lat1000K::lat()
{
    return m_lat;
}


/*!
 * @brief This function copies the value in member payload
 * @param _payload New value to be copied in member payload
 */
void Lat1000K::payload(
        const std::array<uint8_t, 1024000>& _payload)
{
    m_payload = _payload;
}

/*!
 * @brief This function moves the value in member payload
 * @param _payload New value to be moved in member payload
 */
void Lat1000K::payload(
        std::array<uint8_t, 1024000>&& _payload)
{
    m_payload = std::move(_payload);
}

/*!
 * @brief This function returns a constant reference to member payload
 * @return Constant reference to member payload
 */
const std::array<uint8_t, 1024000>& Lat1000K::payload() const
{
    return m_payload;
}

/*!
 * @brief This function returns a reference to member payload
 * @return Reference to member payload
 */
std::array<uint8_t, 1024000>& Lat1000K::payload()
{
    return m_payload;
}


Lat16m::Lat16m()
{

    // Just to register all known types
    registerlatTypes();
}

Lat16m::~Lat16m()
{
}

Lat16m::Lat16m(
        const Lat16m& x)
{
    m_lat = x.m_lat;
    m_payload = x.m_payload;
}

Lat16m::Lat16m(
        Lat16m&& x) noexcept
{
    m_lat = std::move(x.m_lat);
    m_payload = std::move(x.m_payload);
}

Lat16m& Lat16m::operator =(
        const Lat16m& x)
{

    m_lat = x.m_lat;
    m_payload = x.m_payload;

    return *this;
}

Lat16m& Lat16m::operator =(
        Lat16m&& x) noexcept
{

    m_lat = std::move(x.m_lat);
    m_payload = std::move(x.m_payload);

    return *this;
}

bool Lat16m::operator ==(
        const Lat16m& x) const
{
    return (m_lat == x.m_lat &&
           m_payload == x.m_payload);
}

bool Lat16m::operator !=(
        const Lat16m& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member lat
 * @param _lat New value to be copied in member lat
 */
void Lat16m::lat(
        const Lat& _lat)
{
    m_lat = _lat;
}

/*!
 * @brief This function moves the value in member lat
 * @param _lat New value to be moved in member lat
 */
void Lat16m::lat(
        Lat&& _lat)
{
    m_lat = std::move(_lat);
}

/*!
 * @brief This function returns a constant reference to member lat
 * @return Constant reference to member lat
 */
const Lat& Lat16m::lat() const
{
    return m_lat;
}

/*!
 * @brief This function returns a reference to member lat
 * @return Reference to member lat
 */
Lat& Lat16m::lat()
{
    return m_lat;
}


/*!
 * @brief This function copies the value in member payload
 * @param _payload New value to be copied in member payload
 */
void Lat16m::payload(
        const std::array<uint8_t, 16777216>& _payload)
{
    m_payload = _payload;
}

/*!
 * @brief This function moves the value in member payload
 * @param _payload New value to be moved in member payload
 */
void Lat16m::payload(
        std::array<uint8_t, 16777216>&& _payload)
{
    m_payload = std::move(_payload);
}

/*!
 * @brief This function returns a constant reference to member payload
 * @return Constant reference to member payload
 */
const std::array<uint8_t, 16777216>& Lat16m::payload() const
{
    return m_payload;
}

/*!
 * @brief This function returns a reference to member payload
 * @return Reference to member payload
 */
std::array<uint8_t, 16777216>& Lat16m::payload()
{
    return m_payload;
}


// Include auxiliary functions like for serializing/deserializing.
#include "latCdrAux.ipp"
