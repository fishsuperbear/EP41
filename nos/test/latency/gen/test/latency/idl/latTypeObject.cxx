// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file latTypeObject.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool fastddsgen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "lat.h"
#include "latTypeObject.h"
#include <mutex>
#include <utility>
#include <sstream>
#include <fastrtps/rtps/common/SerializedPayload.h>
#include <fastrtps/utils/md5.h>
#include <fastrtps/types/TypeObjectFactory.h>
#include <fastrtps/types/TypeNamesGenerator.h>
#include <fastrtps/types/AnnotationParameterValue.h>
#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>
#include <fastcdr/CdrSizeCalculator.hpp>

using namespace eprosima::fastrtps::rtps;

void registerlatTypes()
{
    static std::once_flag once_flag;
    std::call_once(once_flag, []()
            {
                TypeObjectFactory *factory = TypeObjectFactory::get_instance();
                factory->add_type_object("Lat", GetLatIdentifier(true),
                GetLatObject(true));
                factory->add_type_object("Lat", GetLatIdentifier(false),
                GetLatObject(false));


                factory->add_type_object("LatVar", GetLatVarIdentifier(true),
                GetLatVarObject(true));
                factory->add_type_object("LatVar", GetLatVarIdentifier(false),
                GetLatVarObject(false));


                factory->add_type_object("Lat1K", GetLat1KIdentifier(true),
                GetLat1KObject(true));
                factory->add_type_object("Lat1K", GetLat1KIdentifier(false),
                GetLat1KObject(false));


                factory->add_type_object("Lat10K", GetLat10KIdentifier(true),
                GetLat10KObject(true));
                factory->add_type_object("Lat10K", GetLat10KIdentifier(false),
                GetLat10KObject(false));


                factory->add_type_object("Lat100K", GetLat100KIdentifier(true),
                GetLat100KObject(true));
                factory->add_type_object("Lat100K", GetLat100KIdentifier(false),
                GetLat100KObject(false));


                factory->add_type_object("Lat200K", GetLat200KIdentifier(true),
                GetLat200KObject(true));
                factory->add_type_object("Lat200K", GetLat200KIdentifier(false),
                GetLat200KObject(false));


                factory->add_type_object("Lat500K", GetLat500KIdentifier(true),
                GetLat500KObject(true));
                factory->add_type_object("Lat500K", GetLat500KIdentifier(false),
                GetLat500KObject(false));


                factory->add_type_object("Lat1000K", GetLat1000KIdentifier(true),
                GetLat1000KObject(true));
                factory->add_type_object("Lat1000K", GetLat1000KIdentifier(false),
                GetLat1000KObject(false));


                factory->add_type_object("Lat16m", GetLat16mIdentifier(true),
                GetLat16mObject(true));
                factory->add_type_object("Lat16m", GetLat16mIdentifier(false),
                GetLat16mObject(false));

            });
}

const TypeIdentifier* GetLatIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Lat", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetLatObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("Lat", complete);
}

const TypeObject* GetLatObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Lat", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteLatObject();
    }
    //else
    return GetMinimalLatObject();
}

const TypeObject* GetMinimalLatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Lat", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_timestamp_us;
    mst_timestamp_us.common().member_id(memberId++);
    mst_timestamp_us.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_timestamp_us.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_timestamp_us.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_timestamp_us.common().member_flags().IS_OPTIONAL(false);
    mst_timestamp_us.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_timestamp_us.common().member_flags().IS_KEY(false);
    mst_timestamp_us.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_timestamp_us.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));


    MD5 timestamp_us_hash("timestamp_us");
    for(int i = 0; i < 4; ++i)
    {
        mst_timestamp_us.detail().name_hash()[i] = timestamp_us_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_timestamp_us);

    MinimalStructMember mst_seq;
    mst_seq.common().member_id(memberId++);
    mst_seq.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_seq.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_seq.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_seq.common().member_flags().IS_OPTIONAL(false);
    mst_seq.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_seq.common().member_flags().IS_KEY(false);
    mst_seq.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_seq.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    MD5 seq_hash("seq");
    for(int i = 0; i < 4; ++i)
    {
        mst_seq.detail().name_hash()[i] = seq_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_seq);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Lat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Lat", false);
}

const TypeObject* GetCompleteLatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Lat", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_timestamp_us;
    cst_timestamp_us.common().member_id(memberId++);
    cst_timestamp_us.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_timestamp_us.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_timestamp_us.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_timestamp_us.common().member_flags().IS_OPTIONAL(false);
    cst_timestamp_us.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_timestamp_us.common().member_flags().IS_KEY(false);
    cst_timestamp_us.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_timestamp_us.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));


    cst_timestamp_us.detail().name("timestamp_us");

    type_object->complete().struct_type().member_seq().emplace_back(cst_timestamp_us);

    CompleteStructMember cst_seq;
    cst_seq.common().member_id(memberId++);
    cst_seq.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_seq.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_seq.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_seq.common().member_flags().IS_OPTIONAL(false);
    cst_seq.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_seq.common().member_flags().IS_KEY(false);
    cst_seq.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_seq.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));


    cst_seq.detail().name("seq");

    type_object->complete().struct_type().member_seq().emplace_back(cst_seq);


    // Header
    type_object->complete().struct_type().header().detail().type_name("Lat");
    // TODO inheritance

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Lat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Lat", true);
}

const TypeIdentifier* GetLatVarIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("LatVar", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetLatVarObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("LatVar", complete);
}

const TypeObject* GetLatVarObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("LatVar", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteLatVarObject();
    }
    //else
    return GetMinimalLatVarObject();
}

const TypeObject* GetMinimalLatVarObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("LatVar", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_lat;
    mst_lat.common().member_id(memberId++);
    mst_lat.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_lat.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_lat.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_lat.common().member_flags().IS_OPTIONAL(false);
    mst_lat.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_lat.common().member_flags().IS_KEY(false);
    mst_lat.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_lat.common().member_type_id(*GetLatIdentifier(false));

    MD5 lat_hash("lat");
    for(int i = 0; i < 4; ++i)
    {
        mst_lat.detail().name_hash()[i] = lat_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_lat);

    MinimalStructMember mst_payload;
    mst_payload.common().member_id(memberId++);
    mst_payload.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_payload.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_payload.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_payload.common().member_flags().IS_OPTIONAL(false);
    mst_payload.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_payload.common().member_flags().IS_KEY(false);
    mst_payload.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_payload.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint8_t", 100, false));

    MD5 payload_hash("payload");
    for(int i = 0; i < 4; ++i)
    {
        mst_payload.detail().name_hash()[i] = payload_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_payload);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("LatVar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("LatVar", false);
}

const TypeObject* GetCompleteLatVarObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("LatVar", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_lat;
    cst_lat.common().member_id(memberId++);
    cst_lat.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_lat.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_lat.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_lat.common().member_flags().IS_OPTIONAL(false);
    cst_lat.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_lat.common().member_flags().IS_KEY(false);
    cst_lat.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_lat.common().member_type_id(*GetLatIdentifier(true));

    cst_lat.detail().name("lat");

    type_object->complete().struct_type().member_seq().emplace_back(cst_lat);

    CompleteStructMember cst_payload;
    cst_payload.common().member_id(memberId++);
    cst_payload.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_payload.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_payload.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_payload.common().member_flags().IS_OPTIONAL(false);
    cst_payload.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_payload.common().member_flags().IS_KEY(false);
    cst_payload.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_payload.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint8_t", 100, true));

    cst_payload.detail().name("payload");

    type_object->complete().struct_type().member_seq().emplace_back(cst_payload);


    // Header
    type_object->complete().struct_type().header().detail().type_name("LatVar");
    // TODO inheritance

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("LatVar", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("LatVar", true);
}

const TypeIdentifier* GetLat1KIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Lat1K", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetLat1KObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("Lat1K", complete);
}

const TypeObject* GetLat1KObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Lat1K", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteLat1KObject();
    }
    //else
    return GetMinimalLat1KObject();
}

const TypeObject* GetMinimalLat1KObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Lat1K", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_lat;
    mst_lat.common().member_id(memberId++);
    mst_lat.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_lat.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_lat.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_lat.common().member_flags().IS_OPTIONAL(false);
    mst_lat.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_lat.common().member_flags().IS_KEY(false);
    mst_lat.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_lat.common().member_type_id(*GetLatIdentifier(false));

    MD5 lat_hash("lat");
    for(int i = 0; i < 4; ++i)
    {
        mst_lat.detail().name_hash()[i] = lat_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_lat);

    MinimalStructMember mst_payload;
    mst_payload.common().member_id(memberId++);
    mst_payload.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_payload.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_payload.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_payload.common().member_flags().IS_OPTIONAL(false);
    mst_payload.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_payload.common().member_flags().IS_KEY(false);
    mst_payload.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_payload.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {1024}, false));

    MD5 payload_hash("payload");
    for(int i = 0; i < 4; ++i)
    {
        mst_payload.detail().name_hash()[i] = payload_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_payload);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Lat1K", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Lat1K", false);
}

const TypeObject* GetCompleteLat1KObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Lat1K", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_lat;
    cst_lat.common().member_id(memberId++);
    cst_lat.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_lat.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_lat.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_lat.common().member_flags().IS_OPTIONAL(false);
    cst_lat.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_lat.common().member_flags().IS_KEY(false);
    cst_lat.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_lat.common().member_type_id(*GetLatIdentifier(true));

    cst_lat.detail().name("lat");

    type_object->complete().struct_type().member_seq().emplace_back(cst_lat);

    CompleteStructMember cst_payload;
    cst_payload.common().member_id(memberId++);
    cst_payload.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_payload.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_payload.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_payload.common().member_flags().IS_OPTIONAL(false);
    cst_payload.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_payload.common().member_flags().IS_KEY(false);
    cst_payload.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_payload.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {1024}, true));

    cst_payload.detail().name("payload");

    type_object->complete().struct_type().member_seq().emplace_back(cst_payload);


    // Header
    type_object->complete().struct_type().header().detail().type_name("Lat1K");
    // TODO inheritance

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Lat1K", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Lat1K", true);
}

const TypeIdentifier* GetLat10KIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Lat10K", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetLat10KObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("Lat10K", complete);
}

const TypeObject* GetLat10KObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Lat10K", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteLat10KObject();
    }
    //else
    return GetMinimalLat10KObject();
}

const TypeObject* GetMinimalLat10KObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Lat10K", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_lat;
    mst_lat.common().member_id(memberId++);
    mst_lat.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_lat.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_lat.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_lat.common().member_flags().IS_OPTIONAL(false);
    mst_lat.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_lat.common().member_flags().IS_KEY(false);
    mst_lat.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_lat.common().member_type_id(*GetLatIdentifier(false));

    MD5 lat_hash("lat");
    for(int i = 0; i < 4; ++i)
    {
        mst_lat.detail().name_hash()[i] = lat_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_lat);

    MinimalStructMember mst_payload;
    mst_payload.common().member_id(memberId++);
    mst_payload.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_payload.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_payload.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_payload.common().member_flags().IS_OPTIONAL(false);
    mst_payload.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_payload.common().member_flags().IS_KEY(false);
    mst_payload.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_payload.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {10240}, false));

    MD5 payload_hash("payload");
    for(int i = 0; i < 4; ++i)
    {
        mst_payload.detail().name_hash()[i] = payload_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_payload);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Lat10K", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Lat10K", false);
}

const TypeObject* GetCompleteLat10KObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Lat10K", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_lat;
    cst_lat.common().member_id(memberId++);
    cst_lat.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_lat.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_lat.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_lat.common().member_flags().IS_OPTIONAL(false);
    cst_lat.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_lat.common().member_flags().IS_KEY(false);
    cst_lat.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_lat.common().member_type_id(*GetLatIdentifier(true));

    cst_lat.detail().name("lat");

    type_object->complete().struct_type().member_seq().emplace_back(cst_lat);

    CompleteStructMember cst_payload;
    cst_payload.common().member_id(memberId++);
    cst_payload.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_payload.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_payload.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_payload.common().member_flags().IS_OPTIONAL(false);
    cst_payload.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_payload.common().member_flags().IS_KEY(false);
    cst_payload.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_payload.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {10240}, true));

    cst_payload.detail().name("payload");

    type_object->complete().struct_type().member_seq().emplace_back(cst_payload);


    // Header
    type_object->complete().struct_type().header().detail().type_name("Lat10K");
    // TODO inheritance

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Lat10K", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Lat10K", true);
}

const TypeIdentifier* GetLat100KIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Lat100K", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetLat100KObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("Lat100K", complete);
}

const TypeObject* GetLat100KObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Lat100K", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteLat100KObject();
    }
    //else
    return GetMinimalLat100KObject();
}

const TypeObject* GetMinimalLat100KObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Lat100K", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_lat;
    mst_lat.common().member_id(memberId++);
    mst_lat.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_lat.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_lat.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_lat.common().member_flags().IS_OPTIONAL(false);
    mst_lat.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_lat.common().member_flags().IS_KEY(false);
    mst_lat.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_lat.common().member_type_id(*GetLatIdentifier(false));

    MD5 lat_hash("lat");
    for(int i = 0; i < 4; ++i)
    {
        mst_lat.detail().name_hash()[i] = lat_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_lat);

    MinimalStructMember mst_payload;
    mst_payload.common().member_id(memberId++);
    mst_payload.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_payload.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_payload.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_payload.common().member_flags().IS_OPTIONAL(false);
    mst_payload.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_payload.common().member_flags().IS_KEY(false);
    mst_payload.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_payload.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {102400}, false));

    MD5 payload_hash("payload");
    for(int i = 0; i < 4; ++i)
    {
        mst_payload.detail().name_hash()[i] = payload_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_payload);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Lat100K", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Lat100K", false);
}

const TypeObject* GetCompleteLat100KObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Lat100K", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_lat;
    cst_lat.common().member_id(memberId++);
    cst_lat.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_lat.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_lat.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_lat.common().member_flags().IS_OPTIONAL(false);
    cst_lat.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_lat.common().member_flags().IS_KEY(false);
    cst_lat.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_lat.common().member_type_id(*GetLatIdentifier(true));

    cst_lat.detail().name("lat");

    type_object->complete().struct_type().member_seq().emplace_back(cst_lat);

    CompleteStructMember cst_payload;
    cst_payload.common().member_id(memberId++);
    cst_payload.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_payload.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_payload.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_payload.common().member_flags().IS_OPTIONAL(false);
    cst_payload.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_payload.common().member_flags().IS_KEY(false);
    cst_payload.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_payload.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {102400}, true));

    cst_payload.detail().name("payload");

    type_object->complete().struct_type().member_seq().emplace_back(cst_payload);


    // Header
    type_object->complete().struct_type().header().detail().type_name("Lat100K");
    // TODO inheritance

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Lat100K", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Lat100K", true);
}

const TypeIdentifier* GetLat200KIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Lat200K", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetLat200KObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("Lat200K", complete);
}

const TypeObject* GetLat200KObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Lat200K", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteLat200KObject();
    }
    //else
    return GetMinimalLat200KObject();
}

const TypeObject* GetMinimalLat200KObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Lat200K", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_lat;
    mst_lat.common().member_id(memberId++);
    mst_lat.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_lat.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_lat.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_lat.common().member_flags().IS_OPTIONAL(false);
    mst_lat.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_lat.common().member_flags().IS_KEY(false);
    mst_lat.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_lat.common().member_type_id(*GetLatIdentifier(false));

    MD5 lat_hash("lat");
    for(int i = 0; i < 4; ++i)
    {
        mst_lat.detail().name_hash()[i] = lat_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_lat);

    MinimalStructMember mst_payload;
    mst_payload.common().member_id(memberId++);
    mst_payload.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_payload.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_payload.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_payload.common().member_flags().IS_OPTIONAL(false);
    mst_payload.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_payload.common().member_flags().IS_KEY(false);
    mst_payload.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_payload.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {204800}, false));

    MD5 payload_hash("payload");
    for(int i = 0; i < 4; ++i)
    {
        mst_payload.detail().name_hash()[i] = payload_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_payload);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Lat200K", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Lat200K", false);
}

const TypeObject* GetCompleteLat200KObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Lat200K", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_lat;
    cst_lat.common().member_id(memberId++);
    cst_lat.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_lat.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_lat.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_lat.common().member_flags().IS_OPTIONAL(false);
    cst_lat.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_lat.common().member_flags().IS_KEY(false);
    cst_lat.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_lat.common().member_type_id(*GetLatIdentifier(true));

    cst_lat.detail().name("lat");

    type_object->complete().struct_type().member_seq().emplace_back(cst_lat);

    CompleteStructMember cst_payload;
    cst_payload.common().member_id(memberId++);
    cst_payload.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_payload.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_payload.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_payload.common().member_flags().IS_OPTIONAL(false);
    cst_payload.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_payload.common().member_flags().IS_KEY(false);
    cst_payload.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_payload.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {204800}, true));

    cst_payload.detail().name("payload");

    type_object->complete().struct_type().member_seq().emplace_back(cst_payload);


    // Header
    type_object->complete().struct_type().header().detail().type_name("Lat200K");
    // TODO inheritance

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Lat200K", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Lat200K", true);
}

const TypeIdentifier* GetLat500KIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Lat500K", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetLat500KObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("Lat500K", complete);
}

const TypeObject* GetLat500KObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Lat500K", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteLat500KObject();
    }
    //else
    return GetMinimalLat500KObject();
}

const TypeObject* GetMinimalLat500KObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Lat500K", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_lat;
    mst_lat.common().member_id(memberId++);
    mst_lat.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_lat.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_lat.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_lat.common().member_flags().IS_OPTIONAL(false);
    mst_lat.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_lat.common().member_flags().IS_KEY(false);
    mst_lat.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_lat.common().member_type_id(*GetLatIdentifier(false));

    MD5 lat_hash("lat");
    for(int i = 0; i < 4; ++i)
    {
        mst_lat.detail().name_hash()[i] = lat_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_lat);

    MinimalStructMember mst_payload;
    mst_payload.common().member_id(memberId++);
    mst_payload.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_payload.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_payload.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_payload.common().member_flags().IS_OPTIONAL(false);
    mst_payload.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_payload.common().member_flags().IS_KEY(false);
    mst_payload.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_payload.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {512000}, false));

    MD5 payload_hash("payload");
    for(int i = 0; i < 4; ++i)
    {
        mst_payload.detail().name_hash()[i] = payload_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_payload);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Lat500K", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Lat500K", false);
}

const TypeObject* GetCompleteLat500KObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Lat500K", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_lat;
    cst_lat.common().member_id(memberId++);
    cst_lat.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_lat.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_lat.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_lat.common().member_flags().IS_OPTIONAL(false);
    cst_lat.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_lat.common().member_flags().IS_KEY(false);
    cst_lat.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_lat.common().member_type_id(*GetLatIdentifier(true));

    cst_lat.detail().name("lat");

    type_object->complete().struct_type().member_seq().emplace_back(cst_lat);

    CompleteStructMember cst_payload;
    cst_payload.common().member_id(memberId++);
    cst_payload.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_payload.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_payload.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_payload.common().member_flags().IS_OPTIONAL(false);
    cst_payload.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_payload.common().member_flags().IS_KEY(false);
    cst_payload.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_payload.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {512000}, true));

    cst_payload.detail().name("payload");

    type_object->complete().struct_type().member_seq().emplace_back(cst_payload);


    // Header
    type_object->complete().struct_type().header().detail().type_name("Lat500K");
    // TODO inheritance

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Lat500K", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Lat500K", true);
}

const TypeIdentifier* GetLat1000KIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Lat1000K", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetLat1000KObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("Lat1000K", complete);
}

const TypeObject* GetLat1000KObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Lat1000K", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteLat1000KObject();
    }
    //else
    return GetMinimalLat1000KObject();
}

const TypeObject* GetMinimalLat1000KObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Lat1000K", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_lat;
    mst_lat.common().member_id(memberId++);
    mst_lat.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_lat.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_lat.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_lat.common().member_flags().IS_OPTIONAL(false);
    mst_lat.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_lat.common().member_flags().IS_KEY(false);
    mst_lat.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_lat.common().member_type_id(*GetLatIdentifier(false));

    MD5 lat_hash("lat");
    for(int i = 0; i < 4; ++i)
    {
        mst_lat.detail().name_hash()[i] = lat_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_lat);

    MinimalStructMember mst_payload;
    mst_payload.common().member_id(memberId++);
    mst_payload.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_payload.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_payload.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_payload.common().member_flags().IS_OPTIONAL(false);
    mst_payload.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_payload.common().member_flags().IS_KEY(false);
    mst_payload.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_payload.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {1024000}, false));

    MD5 payload_hash("payload");
    for(int i = 0; i < 4; ++i)
    {
        mst_payload.detail().name_hash()[i] = payload_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_payload);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Lat1000K", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Lat1000K", false);
}

const TypeObject* GetCompleteLat1000KObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Lat1000K", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_lat;
    cst_lat.common().member_id(memberId++);
    cst_lat.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_lat.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_lat.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_lat.common().member_flags().IS_OPTIONAL(false);
    cst_lat.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_lat.common().member_flags().IS_KEY(false);
    cst_lat.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_lat.common().member_type_id(*GetLatIdentifier(true));

    cst_lat.detail().name("lat");

    type_object->complete().struct_type().member_seq().emplace_back(cst_lat);

    CompleteStructMember cst_payload;
    cst_payload.common().member_id(memberId++);
    cst_payload.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_payload.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_payload.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_payload.common().member_flags().IS_OPTIONAL(false);
    cst_payload.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_payload.common().member_flags().IS_KEY(false);
    cst_payload.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_payload.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {1024000}, true));

    cst_payload.detail().name("payload");

    type_object->complete().struct_type().member_seq().emplace_back(cst_payload);


    // Header
    type_object->complete().struct_type().header().detail().type_name("Lat1000K");
    // TODO inheritance

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Lat1000K", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Lat1000K", true);
}

const TypeIdentifier* GetLat16mIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Lat16m", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetLat16mObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("Lat16m", complete);
}

const TypeObject* GetLat16mObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Lat16m", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteLat16mObject();
    }
    //else
    return GetMinimalLat16mObject();
}

const TypeObject* GetMinimalLat16mObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Lat16m", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_lat;
    mst_lat.common().member_id(memberId++);
    mst_lat.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_lat.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_lat.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_lat.common().member_flags().IS_OPTIONAL(false);
    mst_lat.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_lat.common().member_flags().IS_KEY(false);
    mst_lat.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_lat.common().member_type_id(*GetLatIdentifier(false));

    MD5 lat_hash("lat");
    for(int i = 0; i < 4; ++i)
    {
        mst_lat.detail().name_hash()[i] = lat_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_lat);

    MinimalStructMember mst_payload;
    mst_payload.common().member_id(memberId++);
    mst_payload.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_payload.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_payload.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_payload.common().member_flags().IS_OPTIONAL(false);
    mst_payload.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_payload.common().member_flags().IS_KEY(false);
    mst_payload.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_payload.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {16777216}, false));

    MD5 payload_hash("payload");
    for(int i = 0; i < 4; ++i)
    {
        mst_payload.detail().name_hash()[i] = payload_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_payload);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Lat16m", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Lat16m", false);
}

const TypeObject* GetCompleteLat16mObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Lat16m", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_lat;
    cst_lat.common().member_id(memberId++);
    cst_lat.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_lat.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_lat.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_lat.common().member_flags().IS_OPTIONAL(false);
    cst_lat.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_lat.common().member_flags().IS_KEY(false);
    cst_lat.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_lat.common().member_type_id(*GetLatIdentifier(true));

    cst_lat.detail().name("lat");

    type_object->complete().struct_type().member_seq().emplace_back(cst_lat);

    CompleteStructMember cst_payload;
    cst_payload.common().member_id(memberId++);
    cst_payload.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_payload.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_payload.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_payload.common().member_flags().IS_OPTIONAL(false);
    cst_payload.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_payload.common().member_flags().IS_KEY(false);
    cst_payload.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_payload.common().member_type_id(*TypeObjectFactory::get_instance()->get_array_identifier("uint8_t", {16777216}, true));

    cst_payload.detail().name("payload");

    type_object->complete().struct_type().member_seq().emplace_back(cst_payload);


    // Header
    type_object->complete().struct_type().header().detail().type_name("Lat16m");
    // TODO inheritance

    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
    size_t current_alignment {0};
    SerializedPayload_t payload(static_cast<uint32_t>(
        calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    ser << *type_object;
    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Lat16m", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Lat16m", true);
}
