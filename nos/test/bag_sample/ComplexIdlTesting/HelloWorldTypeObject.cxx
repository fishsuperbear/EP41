// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file HelloWorldTypeObject.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "HelloWorld.h"
#include "HelloWorldTypeObject.h"
#include <utility>
#include <sstream>
#include <fastrtps/rtps/common/SerializedPayload.h>
#include <fastrtps/utils/md5.h>
#include <fastrtps/types/TypeObjectFactory.h>
#include <fastrtps/types/TypeNamesGenerator.h>
#include <fastrtps/types/AnnotationParameterValue.h>
#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>

using namespace eprosima::fastrtps::rtps;

void registerHelloWorldTypes()
{
    TypeObjectFactory *factory = TypeObjectFactory::get_instance();
    factory->add_type_object("BaseHeader", GetBaseHeaderIdentifier(true),
    GetBaseHeaderObject(true));
    factory->add_type_object("BaseHeader", GetBaseHeaderIdentifier(false),
    GetBaseHeaderObject(false));

    factory->add_type_object("Time", GetTimeIdentifier(true),
    GetTimeObject(true));
    factory->add_type_object("Time", GetTimeIdentifier(false),
    GetTimeObject(false));

    factory->add_type_object("Point3DFloat", GetPoint3DFloatIdentifier(true),
    GetPoint3DFloatObject(true));
    factory->add_type_object("Point3DFloat", GetPoint3DFloatIdentifier(false),
    GetPoint3DFloatObject(false));

    factory->add_type_object("Point3DDouble", GetPoint3DDoubleIdentifier(true),
    GetPoint3DDoubleObject(true));
    factory->add_type_object("Point3DDouble", GetPoint3DDoubleIdentifier(false),
    GetPoint3DDoubleObject(false));

    factory->add_type_object("AlgRect3D", GetAlgRect3DIdentifier(true),
    GetAlgRect3DObject(true));
    factory->add_type_object("AlgRect3D", GetAlgRect3DIdentifier(false),
    GetAlgRect3DObject(false));

    factory->add_type_object("ObjectInfo", GetObjectInfoIdentifier(true),
    GetObjectInfoObject(true));
    factory->add_type_object("ObjectInfo", GetObjectInfoIdentifier(false),
    GetObjectInfoObject(false));

    factory->add_type_object("ObjectVec", GetObjectVecIdentifier(true),
    GetObjectVecObject(true));
    factory->add_type_object("ObjectVec", GetObjectVecIdentifier(false),
    GetObjectVecObject(false));

}

const TypeIdentifier* GetBaseHeaderIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("BaseHeader", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetBaseHeaderObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("BaseHeader", complete);
}

const TypeObject* GetBaseHeaderObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BaseHeader", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteBaseHeaderObject();
    }
    //else
    return GetMinimalBaseHeaderObject();
}

const TypeObject* GetMinimalBaseHeaderObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BaseHeader", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_seq;
    mst_seq.common().member_id(memberId++);
    mst_seq.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_seq.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_seq.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_seq.common().member_flags().IS_OPTIONAL(false);
    mst_seq.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_seq.common().member_flags().IS_KEY(false);
    mst_seq.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_seq.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 seq_hash("seq");
    for(int i = 0; i < 4; ++i)
    {
        mst_seq.detail().name_hash()[i] = seq_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_seq);

    MinimalStructMember mst_data_timestamp_us;
    mst_data_timestamp_us.common().member_id(memberId++);
    mst_data_timestamp_us.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_data_timestamp_us.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_data_timestamp_us.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_data_timestamp_us.common().member_flags().IS_OPTIONAL(false);
    mst_data_timestamp_us.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_data_timestamp_us.common().member_flags().IS_KEY(false);
    mst_data_timestamp_us.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_data_timestamp_us.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    MD5 data_timestamp_us_hash("data_timestamp_us");
    for(int i = 0; i < 4; ++i)
    {
        mst_data_timestamp_us.detail().name_hash()[i] = data_timestamp_us_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_data_timestamp_us);

    MinimalStructMember mst_send_timestamp_us;
    mst_send_timestamp_us.common().member_id(memberId++);
    mst_send_timestamp_us.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_send_timestamp_us.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_send_timestamp_us.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_send_timestamp_us.common().member_flags().IS_OPTIONAL(false);
    mst_send_timestamp_us.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_send_timestamp_us.common().member_flags().IS_KEY(false);
    mst_send_timestamp_us.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_send_timestamp_us.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    MD5 send_timestamp_us_hash("send_timestamp_us");
    for(int i = 0; i < 4; ++i)
    {
        mst_send_timestamp_us.detail().name_hash()[i] = send_timestamp_us_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_send_timestamp_us);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("BaseHeader", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("BaseHeader", false);
}

const TypeObject* GetCompleteBaseHeaderObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("BaseHeader", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_seq;
    cst_seq.common().member_id(memberId++);
    cst_seq.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_seq.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_seq.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_seq.common().member_flags().IS_OPTIONAL(false);
    cst_seq.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_seq.common().member_flags().IS_KEY(false);
    cst_seq.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_seq.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_seq.detail().name("seq");

    type_object->complete().struct_type().member_seq().emplace_back(cst_seq);

    CompleteStructMember cst_data_timestamp_us;
    cst_data_timestamp_us.common().member_id(memberId++);
    cst_data_timestamp_us.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_data_timestamp_us.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_data_timestamp_us.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_data_timestamp_us.common().member_flags().IS_OPTIONAL(false);
    cst_data_timestamp_us.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_data_timestamp_us.common().member_flags().IS_KEY(false);
    cst_data_timestamp_us.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_data_timestamp_us.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    cst_data_timestamp_us.detail().name("data_timestamp_us");

    type_object->complete().struct_type().member_seq().emplace_back(cst_data_timestamp_us);

    CompleteStructMember cst_send_timestamp_us;
    cst_send_timestamp_us.common().member_id(memberId++);
    cst_send_timestamp_us.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_send_timestamp_us.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_send_timestamp_us.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_send_timestamp_us.common().member_flags().IS_OPTIONAL(false);
    cst_send_timestamp_us.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_send_timestamp_us.common().member_flags().IS_KEY(false);
    cst_send_timestamp_us.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_send_timestamp_us.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    cst_send_timestamp_us.detail().name("send_timestamp_us");

    type_object->complete().struct_type().member_seq().emplace_back(cst_send_timestamp_us);


    // Header
    type_object->complete().struct_type().header().detail().type_name("BaseHeader");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("BaseHeader", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("BaseHeader", true);
}

const TypeIdentifier* GetTimeIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Time", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetTimeObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("Time", complete);
}

const TypeObject* GetTimeObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Time", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteTimeObject();
    }
    //else
    return GetMinimalTimeObject();
}

const TypeObject* GetMinimalTimeObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Time", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_sec;
    mst_sec.common().member_id(memberId++);
    mst_sec.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_sec.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_sec.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_sec.common().member_flags().IS_OPTIONAL(false);
    mst_sec.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_sec.common().member_flags().IS_KEY(false);
    mst_sec.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_sec.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    MD5 sec_hash("sec");
    for(int i = 0; i < 4; ++i)
    {
        mst_sec.detail().name_hash()[i] = sec_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_sec);

    MinimalStructMember mst_nsec;
    mst_nsec.common().member_id(memberId++);
    mst_nsec.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_nsec.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_nsec.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_nsec.common().member_flags().IS_OPTIONAL(false);
    mst_nsec.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_nsec.common().member_flags().IS_KEY(false);
    mst_nsec.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_nsec.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    MD5 nsec_hash("nsec");
    for(int i = 0; i < 4; ++i)
    {
        mst_nsec.detail().name_hash()[i] = nsec_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_nsec);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Time", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Time", false);
}

const TypeObject* GetCompleteTimeObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Time", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_sec;
    cst_sec.common().member_id(memberId++);
    cst_sec.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_sec.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_sec.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_sec.common().member_flags().IS_OPTIONAL(false);
    cst_sec.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_sec.common().member_flags().IS_KEY(false);
    cst_sec.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_sec.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    cst_sec.detail().name("sec");

    type_object->complete().struct_type().member_seq().emplace_back(cst_sec);

    CompleteStructMember cst_nsec;
    cst_nsec.common().member_id(memberId++);
    cst_nsec.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_nsec.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_nsec.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_nsec.common().member_flags().IS_OPTIONAL(false);
    cst_nsec.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_nsec.common().member_flags().IS_KEY(false);
    cst_nsec.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_nsec.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint64_t", false));

    cst_nsec.detail().name("nsec");

    type_object->complete().struct_type().member_seq().emplace_back(cst_nsec);


    // Header
    type_object->complete().struct_type().header().detail().type_name("Time");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Time", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Time", true);
}

const TypeIdentifier* GetPoint3DFloatIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Point3DFloat", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetPoint3DFloatObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("Point3DFloat", complete);
}

const TypeObject* GetPoint3DFloatObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Point3DFloat", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletePoint3DFloatObject();
    }
    //else
    return GetMinimalPoint3DFloatObject();
}

const TypeObject* GetMinimalPoint3DFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Point3DFloat", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_x;
    mst_x.common().member_id(memberId++);
    mst_x.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_x.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_x.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_x.common().member_flags().IS_OPTIONAL(false);
    mst_x.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_x.common().member_flags().IS_KEY(false);
    mst_x.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_x.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    MD5 x_hash("x");
    for(int i = 0; i < 4; ++i)
    {
        mst_x.detail().name_hash()[i] = x_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_x);

    MinimalStructMember mst_y;
    mst_y.common().member_id(memberId++);
    mst_y.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_y.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_y.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_y.common().member_flags().IS_OPTIONAL(false);
    mst_y.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_y.common().member_flags().IS_KEY(false);
    mst_y.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_y.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    MD5 y_hash("y");
    for(int i = 0; i < 4; ++i)
    {
        mst_y.detail().name_hash()[i] = y_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_y);

    MinimalStructMember mst_z;
    mst_z.common().member_id(memberId++);
    mst_z.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_z.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_z.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_z.common().member_flags().IS_OPTIONAL(false);
    mst_z.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_z.common().member_flags().IS_KEY(false);
    mst_z.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_z.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    MD5 z_hash("z");
    for(int i = 0; i < 4; ++i)
    {
        mst_z.detail().name_hash()[i] = z_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_z);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Point3DFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Point3DFloat", false);
}

const TypeObject* GetCompletePoint3DFloatObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Point3DFloat", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_x;
    cst_x.common().member_id(memberId++);
    cst_x.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_x.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_x.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_x.common().member_flags().IS_OPTIONAL(false);
    cst_x.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_x.common().member_flags().IS_KEY(false);
    cst_x.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_x.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    cst_x.detail().name("x");

    type_object->complete().struct_type().member_seq().emplace_back(cst_x);

    CompleteStructMember cst_y;
    cst_y.common().member_id(memberId++);
    cst_y.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_y.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_y.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_y.common().member_flags().IS_OPTIONAL(false);
    cst_y.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_y.common().member_flags().IS_KEY(false);
    cst_y.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_y.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    cst_y.detail().name("y");

    type_object->complete().struct_type().member_seq().emplace_back(cst_y);

    CompleteStructMember cst_z;
    cst_z.common().member_id(memberId++);
    cst_z.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_z.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_z.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_z.common().member_flags().IS_OPTIONAL(false);
    cst_z.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_z.common().member_flags().IS_KEY(false);
    cst_z.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_z.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    cst_z.detail().name("z");

    type_object->complete().struct_type().member_seq().emplace_back(cst_z);


    // Header
    type_object->complete().struct_type().header().detail().type_name("Point3DFloat");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Point3DFloat", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Point3DFloat", true);
}

const TypeIdentifier* GetPoint3DDoubleIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("Point3DDouble", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetPoint3DDoubleObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("Point3DDouble", complete);
}

const TypeObject* GetPoint3DDoubleObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Point3DDouble", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompletePoint3DDoubleObject();
    }
    //else
    return GetMinimalPoint3DDoubleObject();
}

const TypeObject* GetMinimalPoint3DDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Point3DDouble", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_x;
    mst_x.common().member_id(memberId++);
    mst_x.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_x.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_x.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_x.common().member_flags().IS_OPTIONAL(false);
    mst_x.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_x.common().member_flags().IS_KEY(false);
    mst_x.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_x.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    MD5 x_hash("x");
    for(int i = 0; i < 4; ++i)
    {
        mst_x.detail().name_hash()[i] = x_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_x);

    MinimalStructMember mst_y;
    mst_y.common().member_id(memberId++);
    mst_y.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_y.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_y.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_y.common().member_flags().IS_OPTIONAL(false);
    mst_y.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_y.common().member_flags().IS_KEY(false);
    mst_y.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_y.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    MD5 y_hash("y");
    for(int i = 0; i < 4; ++i)
    {
        mst_y.detail().name_hash()[i] = y_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_y);

    MinimalStructMember mst_z;
    mst_z.common().member_id(memberId++);
    mst_z.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_z.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_z.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_z.common().member_flags().IS_OPTIONAL(false);
    mst_z.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_z.common().member_flags().IS_KEY(false);
    mst_z.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_z.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    MD5 z_hash("z");
    for(int i = 0; i < 4; ++i)
    {
        mst_z.detail().name_hash()[i] = z_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_z);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Point3DDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Point3DDouble", false);
}

const TypeObject* GetCompletePoint3DDoubleObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("Point3DDouble", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_x;
    cst_x.common().member_id(memberId++);
    cst_x.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_x.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_x.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_x.common().member_flags().IS_OPTIONAL(false);
    cst_x.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_x.common().member_flags().IS_KEY(false);
    cst_x.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_x.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    cst_x.detail().name("x");

    type_object->complete().struct_type().member_seq().emplace_back(cst_x);

    CompleteStructMember cst_y;
    cst_y.common().member_id(memberId++);
    cst_y.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_y.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_y.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_y.common().member_flags().IS_OPTIONAL(false);
    cst_y.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_y.common().member_flags().IS_KEY(false);
    cst_y.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_y.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    cst_y.detail().name("y");

    type_object->complete().struct_type().member_seq().emplace_back(cst_y);

    CompleteStructMember cst_z;
    cst_z.common().member_id(memberId++);
    cst_z.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_z.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_z.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_z.common().member_flags().IS_OPTIONAL(false);
    cst_z.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_z.common().member_flags().IS_KEY(false);
    cst_z.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_z.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    cst_z.detail().name("z");

    type_object->complete().struct_type().member_seq().emplace_back(cst_z);


    // Header
    type_object->complete().struct_type().header().detail().type_name("Point3DDouble");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("Point3DDouble", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("Point3DDouble", true);
}

const TypeIdentifier* GetAlgRect3DIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("AlgRect3D", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetAlgRect3DObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("AlgRect3D", complete);
}

const TypeObject* GetAlgRect3DObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AlgRect3D", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteAlgRect3DObject();
    }
    //else
    return GetMinimalAlgRect3DObject();
}

const TypeObject* GetMinimalAlgRect3DObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AlgRect3D", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_center;
    mst_center.common().member_id(memberId++);
    mst_center.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_center.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_center.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_center.common().member_flags().IS_OPTIONAL(false);
    mst_center.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_center.common().member_flags().IS_KEY(false);
    mst_center.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_center.common().member_type_id(*GetPoint3DFloatIdentifier(false));
    MD5 center_hash("center");
    for(int i = 0; i < 4; ++i)
    {
        mst_center.detail().name_hash()[i] = center_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_center);

    MinimalStructMember mst_centerstddev;
    mst_centerstddev.common().member_id(memberId++);
    mst_centerstddev.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_centerstddev.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_centerstddev.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_centerstddev.common().member_flags().IS_OPTIONAL(false);
    mst_centerstddev.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_centerstddev.common().member_flags().IS_KEY(false);
    mst_centerstddev.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_centerstddev.common().member_type_id(*GetPoint3DDoubleIdentifier(false));
    MD5 centerstddev_hash("centerstddev");
    for(int i = 0; i < 4; ++i)
    {
        mst_centerstddev.detail().name_hash()[i] = centerstddev_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_centerstddev);

    MinimalStructMember mst_sizelwh;
    mst_sizelwh.common().member_id(memberId++);
    mst_sizelwh.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_sizelwh.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_sizelwh.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_sizelwh.common().member_flags().IS_OPTIONAL(false);
    mst_sizelwh.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_sizelwh.common().member_flags().IS_KEY(false);
    mst_sizelwh.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_sizelwh.common().member_type_id(*GetPoint3DFloatIdentifier(false));
    MD5 sizelwh_hash("sizelwh");
    for(int i = 0; i < 4; ++i)
    {
        mst_sizelwh.detail().name_hash()[i] = sizelwh_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_sizelwh);

    MinimalStructMember mst_sizestddev;
    mst_sizestddev.common().member_id(memberId++);
    mst_sizestddev.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_sizestddev.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_sizestddev.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_sizestddev.common().member_flags().IS_OPTIONAL(false);
    mst_sizestddev.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_sizestddev.common().member_flags().IS_KEY(false);
    mst_sizestddev.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_sizestddev.common().member_type_id(*GetPoint3DDoubleIdentifier(false));
    MD5 sizestddev_hash("sizestddev");
    for(int i = 0; i < 4; ++i)
    {
        mst_sizestddev.detail().name_hash()[i] = sizestddev_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_sizestddev);

    MinimalStructMember mst_orientation;
    mst_orientation.common().member_id(memberId++);
    mst_orientation.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_orientation.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_orientation.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_orientation.common().member_flags().IS_OPTIONAL(false);
    mst_orientation.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_orientation.common().member_flags().IS_KEY(false);
    mst_orientation.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_orientation.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    MD5 orientation_hash("orientation");
    for(int i = 0; i < 4; ++i)
    {
        mst_orientation.detail().name_hash()[i] = orientation_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_orientation);

    MinimalStructMember mst_orientationstddev;
    mst_orientationstddev.common().member_id(memberId++);
    mst_orientationstddev.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_orientationstddev.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_orientationstddev.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_orientationstddev.common().member_flags().IS_OPTIONAL(false);
    mst_orientationstddev.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_orientationstddev.common().member_flags().IS_KEY(false);
    mst_orientationstddev.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_orientationstddev.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    MD5 orientationstddev_hash("orientationstddev");
    for(int i = 0; i < 4; ++i)
    {
        mst_orientationstddev.detail().name_hash()[i] = orientationstddev_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_orientationstddev);

    MinimalStructMember mst_corners;
    mst_corners.common().member_id(memberId++);
    mst_corners.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_corners.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_corners.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_corners.common().member_flags().IS_OPTIONAL(false);
    mst_corners.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_corners.common().member_flags().IS_KEY(false);
    mst_corners.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_corners.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("Point3DFloat", 0, false));


    MD5 corners_hash("corners");
    for(int i = 0; i < 4; ++i)
    {
        mst_corners.detail().name_hash()[i] = corners_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_corners);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AlgRect3D", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AlgRect3D", false);
}

const TypeObject* GetCompleteAlgRect3DObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("AlgRect3D", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_center;
    cst_center.common().member_id(memberId++);
    cst_center.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_center.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_center.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_center.common().member_flags().IS_OPTIONAL(false);
    cst_center.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_center.common().member_flags().IS_KEY(false);
    cst_center.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_center.common().member_type_id(*GetPoint3DFloatIdentifier(true));
    cst_center.detail().name("center");

    type_object->complete().struct_type().member_seq().emplace_back(cst_center);

    CompleteStructMember cst_centerstddev;
    cst_centerstddev.common().member_id(memberId++);
    cst_centerstddev.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_centerstddev.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_centerstddev.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_centerstddev.common().member_flags().IS_OPTIONAL(false);
    cst_centerstddev.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_centerstddev.common().member_flags().IS_KEY(false);
    cst_centerstddev.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_centerstddev.common().member_type_id(*GetPoint3DDoubleIdentifier(true));
    cst_centerstddev.detail().name("centerstddev");

    type_object->complete().struct_type().member_seq().emplace_back(cst_centerstddev);

    CompleteStructMember cst_sizelwh;
    cst_sizelwh.common().member_id(memberId++);
    cst_sizelwh.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_sizelwh.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_sizelwh.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_sizelwh.common().member_flags().IS_OPTIONAL(false);
    cst_sizelwh.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_sizelwh.common().member_flags().IS_KEY(false);
    cst_sizelwh.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_sizelwh.common().member_type_id(*GetPoint3DFloatIdentifier(true));
    cst_sizelwh.detail().name("sizelwh");

    type_object->complete().struct_type().member_seq().emplace_back(cst_sizelwh);

    CompleteStructMember cst_sizestddev;
    cst_sizestddev.common().member_id(memberId++);
    cst_sizestddev.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_sizestddev.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_sizestddev.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_sizestddev.common().member_flags().IS_OPTIONAL(false);
    cst_sizestddev.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_sizestddev.common().member_flags().IS_KEY(false);
    cst_sizestddev.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_sizestddev.common().member_type_id(*GetPoint3DDoubleIdentifier(true));
    cst_sizestddev.detail().name("sizestddev");

    type_object->complete().struct_type().member_seq().emplace_back(cst_sizestddev);

    CompleteStructMember cst_orientation;
    cst_orientation.common().member_id(memberId++);
    cst_orientation.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_orientation.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_orientation.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_orientation.common().member_flags().IS_OPTIONAL(false);
    cst_orientation.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_orientation.common().member_flags().IS_KEY(false);
    cst_orientation.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_orientation.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    cst_orientation.detail().name("orientation");

    type_object->complete().struct_type().member_seq().emplace_back(cst_orientation);

    CompleteStructMember cst_orientationstddev;
    cst_orientationstddev.common().member_id(memberId++);
    cst_orientationstddev.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_orientationstddev.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_orientationstddev.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_orientationstddev.common().member_flags().IS_OPTIONAL(false);
    cst_orientationstddev.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_orientationstddev.common().member_flags().IS_KEY(false);
    cst_orientationstddev.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_orientationstddev.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("double", false));

    cst_orientationstddev.detail().name("orientationstddev");

    type_object->complete().struct_type().member_seq().emplace_back(cst_orientationstddev);

    CompleteStructMember cst_corners;
    cst_corners.common().member_id(memberId++);
    cst_corners.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_corners.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_corners.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_corners.common().member_flags().IS_OPTIONAL(false);
    cst_corners.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_corners.common().member_flags().IS_KEY(false);
    cst_corners.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_corners.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("Point3DFloat", 0, true));


    cst_corners.detail().name("corners");

    type_object->complete().struct_type().member_seq().emplace_back(cst_corners);


    // Header
    type_object->complete().struct_type().header().detail().type_name("AlgRect3D");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("AlgRect3D", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("AlgRect3D", true);
}

const TypeIdentifier* GetObjectInfoIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ObjectInfo", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetObjectInfoObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ObjectInfo", complete);
}

const TypeObject* GetObjectInfoObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ObjectInfo", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteObjectInfoObject();
    }
    //else
    return GetMinimalObjectInfoObject();
}

const TypeObject* GetMinimalObjectInfoObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ObjectInfo", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_header;
    mst_header.common().member_id(memberId++);
    mst_header.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_header.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_header.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_header.common().member_flags().IS_OPTIONAL(false);
    mst_header.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_header.common().member_flags().IS_KEY(false);
    mst_header.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_header.common().member_type_id(*GetBaseHeaderIdentifier(false));
    MD5 header_hash("header");
    for(int i = 0; i < 4; ++i)
    {
        mst_header.detail().name_hash()[i] = header_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_header);

    MinimalStructMember mst_objectid;
    mst_objectid.common().member_id(memberId++);
    mst_objectid.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_objectid.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_objectid.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_objectid.common().member_flags().IS_OPTIONAL(false);
    mst_objectid.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_objectid.common().member_flags().IS_KEY(false);
    mst_objectid.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_objectid.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 objectid_hash("objectid");
    for(int i = 0; i < 4; ++i)
    {
        mst_objectid.detail().name_hash()[i] = objectid_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_objectid);

    MinimalStructMember mst_type;
    mst_type.common().member_id(memberId++);
    mst_type.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_type.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_type.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_type.common().member_flags().IS_OPTIONAL(false);
    mst_type.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_type.common().member_flags().IS_KEY(false);
    mst_type.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_type.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 type_hash("type");
    for(int i = 0; i < 4; ++i)
    {
        mst_type.detail().name_hash()[i] = type_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_type);

    MinimalStructMember mst_detectsensor_current;
    mst_detectsensor_current.common().member_id(memberId++);
    mst_detectsensor_current.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_detectsensor_current.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_detectsensor_current.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_detectsensor_current.common().member_flags().IS_OPTIONAL(false);
    mst_detectsensor_current.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_detectsensor_current.common().member_flags().IS_KEY(false);
    mst_detectsensor_current.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_detectsensor_current.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 detectsensor_current_hash("detectsensor_current");
    for(int i = 0; i < 4; ++i)
    {
        mst_detectsensor_current.detail().name_hash()[i] = detectsensor_current_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_detectsensor_current);

    MinimalStructMember mst_detectsensor_history;
    mst_detectsensor_history.common().member_id(memberId++);
    mst_detectsensor_history.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_detectsensor_history.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_detectsensor_history.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_detectsensor_history.common().member_flags().IS_OPTIONAL(false);
    mst_detectsensor_history.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_detectsensor_history.common().member_flags().IS_KEY(false);
    mst_detectsensor_history.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_detectsensor_history.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 detectsensor_history_hash("detectsensor_history");
    for(int i = 0; i < 4; ++i)
    {
        mst_detectsensor_history.detail().name_hash()[i] = detectsensor_history_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_detectsensor_history);

    MinimalStructMember mst_maintenancestatus;
    mst_maintenancestatus.common().member_id(memberId++);
    mst_maintenancestatus.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_maintenancestatus.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_maintenancestatus.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_maintenancestatus.common().member_flags().IS_OPTIONAL(false);
    mst_maintenancestatus.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_maintenancestatus.common().member_flags().IS_KEY(false);
    mst_maintenancestatus.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_maintenancestatus.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 maintenancestatus_hash("maintenancestatus");
    for(int i = 0; i < 4; ++i)
    {
        mst_maintenancestatus.detail().name_hash()[i] = maintenancestatus_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_maintenancestatus);

    MinimalStructMember mst_typeconfidence;
    mst_typeconfidence.common().member_id(memberId++);
    mst_typeconfidence.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_typeconfidence.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_typeconfidence.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_typeconfidence.common().member_flags().IS_OPTIONAL(false);
    mst_typeconfidence.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_typeconfidence.common().member_flags().IS_KEY(false);
    mst_typeconfidence.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_typeconfidence.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    MD5 typeconfidence_hash("typeconfidence");
    for(int i = 0; i < 4; ++i)
    {
        mst_typeconfidence.detail().name_hash()[i] = typeconfidence_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_typeconfidence);

    MinimalStructMember mst_existenceprobability;
    mst_existenceprobability.common().member_id(memberId++);
    mst_existenceprobability.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_existenceprobability.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_existenceprobability.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_existenceprobability.common().member_flags().IS_OPTIONAL(false);
    mst_existenceprobability.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_existenceprobability.common().member_flags().IS_KEY(false);
    mst_existenceprobability.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_existenceprobability.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    MD5 existenceprobability_hash("existenceprobability");
    for(int i = 0; i < 4; ++i)
    {
        mst_existenceprobability.detail().name_hash()[i] = existenceprobability_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_existenceprobability);

    MinimalStructMember mst_rectinfo;
    mst_rectinfo.common().member_id(memberId++);
    mst_rectinfo.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_rectinfo.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_rectinfo.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_rectinfo.common().member_flags().IS_OPTIONAL(false);
    mst_rectinfo.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_rectinfo.common().member_flags().IS_KEY(false);
    mst_rectinfo.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_rectinfo.common().member_type_id(*GetAlgRect3DIdentifier(false));
    MD5 rectinfo_hash("rectinfo");
    for(int i = 0; i < 4; ++i)
    {
        mst_rectinfo.detail().name_hash()[i] = rectinfo_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_rectinfo);

    MinimalStructMember mst_velocityabs;
    mst_velocityabs.common().member_id(memberId++);
    mst_velocityabs.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_velocityabs.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_velocityabs.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_velocityabs.common().member_flags().IS_OPTIONAL(false);
    mst_velocityabs.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_velocityabs.common().member_flags().IS_KEY(false);
    mst_velocityabs.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_velocityabs.common().member_type_id(*GetPoint3DFloatIdentifier(false));
    MD5 velocityabs_hash("velocityabs");
    for(int i = 0; i < 4; ++i)
    {
        mst_velocityabs.detail().name_hash()[i] = velocityabs_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_velocityabs);

    MinimalStructMember mst_accelerationabs;
    mst_accelerationabs.common().member_id(memberId++);
    mst_accelerationabs.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_accelerationabs.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_accelerationabs.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_accelerationabs.common().member_flags().IS_OPTIONAL(false);
    mst_accelerationabs.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_accelerationabs.common().member_flags().IS_KEY(false);
    mst_accelerationabs.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_accelerationabs.common().member_type_id(*GetPoint3DFloatIdentifier(false));
    MD5 accelerationabs_hash("accelerationabs");
    for(int i = 0; i < 4; ++i)
    {
        mst_accelerationabs.detail().name_hash()[i] = accelerationabs_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_accelerationabs);

    MinimalStructMember mst_timecreation;
    mst_timecreation.common().member_id(memberId++);
    mst_timecreation.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_timecreation.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_timecreation.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_timecreation.common().member_flags().IS_OPTIONAL(false);
    mst_timecreation.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_timecreation.common().member_flags().IS_KEY(false);
    mst_timecreation.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_timecreation.common().member_type_id(*GetTimeIdentifier(false));
    MD5 timecreation_hash("timecreation");
    for(int i = 0; i < 4; ++i)
    {
        mst_timecreation.detail().name_hash()[i] = timecreation_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_timecreation);

    MinimalStructMember mst_lastupdatedtime;
    mst_lastupdatedtime.common().member_id(memberId++);
    mst_lastupdatedtime.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_lastupdatedtime.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_lastupdatedtime.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_lastupdatedtime.common().member_flags().IS_OPTIONAL(false);
    mst_lastupdatedtime.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_lastupdatedtime.common().member_flags().IS_KEY(false);
    mst_lastupdatedtime.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_lastupdatedtime.common().member_type_id(*GetTimeIdentifier(false));
    MD5 lastupdatedtime_hash("lastupdatedtime");
    for(int i = 0; i < 4; ++i)
    {
        mst_lastupdatedtime.detail().name_hash()[i] = lastupdatedtime_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_lastupdatedtime);

    MinimalStructMember mst_sensorid;
    mst_sensorid.common().member_id(memberId++);
    mst_sensorid.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_sensorid.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_sensorid.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_sensorid.common().member_flags().IS_OPTIONAL(false);
    mst_sensorid.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_sensorid.common().member_flags().IS_KEY(false);
    mst_sensorid.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_sensorid.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint32_t", 0, false));


    MD5 sensorid_hash("sensorid");
    for(int i = 0; i < 4; ++i)
    {
        mst_sensorid.detail().name_hash()[i] = sensorid_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_sensorid);

    MinimalStructMember mst_motionpattern;
    mst_motionpattern.common().member_id(memberId++);
    mst_motionpattern.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_motionpattern.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_motionpattern.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_motionpattern.common().member_flags().IS_OPTIONAL(false);
    mst_motionpattern.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_motionpattern.common().member_flags().IS_KEY(false);
    mst_motionpattern.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_motionpattern.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 motionpattern_hash("motionpattern");
    for(int i = 0; i < 4; ++i)
    {
        mst_motionpattern.detail().name_hash()[i] = motionpattern_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_motionpattern);

    MinimalStructMember mst_motionpatternhistory;
    mst_motionpatternhistory.common().member_id(memberId++);
    mst_motionpatternhistory.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_motionpatternhistory.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_motionpatternhistory.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_motionpatternhistory.common().member_flags().IS_OPTIONAL(false);
    mst_motionpatternhistory.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_motionpatternhistory.common().member_flags().IS_KEY(false);
    mst_motionpatternhistory.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_motionpatternhistory.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 motionpatternhistory_hash("motionpatternhistory");
    for(int i = 0; i < 4; ++i)
    {
        mst_motionpatternhistory.detail().name_hash()[i] = motionpatternhistory_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_motionpatternhistory);

    MinimalStructMember mst_brakelightst;
    mst_brakelightst.common().member_id(memberId++);
    mst_brakelightst.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_brakelightst.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_brakelightst.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_brakelightst.common().member_flags().IS_OPTIONAL(false);
    mst_brakelightst.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_brakelightst.common().member_flags().IS_KEY(false);
    mst_brakelightst.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_brakelightst.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 brakelightst_hash("brakelightst");
    for(int i = 0; i < 4; ++i)
    {
        mst_brakelightst.detail().name_hash()[i] = brakelightst_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_brakelightst);

    MinimalStructMember mst_turnlightst;
    mst_turnlightst.common().member_id(memberId++);
    mst_turnlightst.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_turnlightst.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_turnlightst.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_turnlightst.common().member_flags().IS_OPTIONAL(false);
    mst_turnlightst.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_turnlightst.common().member_flags().IS_KEY(false);
    mst_turnlightst.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_turnlightst.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 turnlightst_hash("turnlightst");
    for(int i = 0; i < 4; ++i)
    {
        mst_turnlightst.detail().name_hash()[i] = turnlightst_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_turnlightst);

    MinimalStructMember mst_nearside;
    mst_nearside.common().member_id(memberId++);
    mst_nearside.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_nearside.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_nearside.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_nearside.common().member_flags().IS_OPTIONAL(false);
    mst_nearside.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_nearside.common().member_flags().IS_KEY(false);
    mst_nearside.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_nearside.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 nearside_hash("nearside");
    for(int i = 0; i < 4; ++i)
    {
        mst_nearside.detail().name_hash()[i] = nearside_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_nearside);

    MinimalStructMember mst_associatedconf;
    mst_associatedconf.common().member_id(memberId++);
    mst_associatedconf.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_associatedconf.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_associatedconf.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_associatedconf.common().member_flags().IS_OPTIONAL(false);
    mst_associatedconf.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_associatedconf.common().member_flags().IS_KEY(false);
    mst_associatedconf.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_associatedconf.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("float", 0, false));


    MD5 associatedconf_hash("associatedconf");
    for(int i = 0; i < 4; ++i)
    {
        mst_associatedconf.detail().name_hash()[i] = associatedconf_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_associatedconf);

    MinimalStructMember mst_age;
    mst_age.common().member_id(memberId++);
    mst_age.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_age.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_age.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_age.common().member_flags().IS_OPTIONAL(false);
    mst_age.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_age.common().member_flags().IS_KEY(false);
    mst_age.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_age.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    MD5 age_hash("age");
    for(int i = 0; i < 4; ++i)
    {
        mst_age.detail().name_hash()[i] = age_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_age);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ObjectInfo", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ObjectInfo", false);
}

const TypeObject* GetCompleteObjectInfoObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ObjectInfo", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_header;
    cst_header.common().member_id(memberId++);
    cst_header.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_header.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_header.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_header.common().member_flags().IS_OPTIONAL(false);
    cst_header.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_header.common().member_flags().IS_KEY(false);
    cst_header.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_header.common().member_type_id(*GetBaseHeaderIdentifier(true));
    cst_header.detail().name("header");

    type_object->complete().struct_type().member_seq().emplace_back(cst_header);

    CompleteStructMember cst_objectid;
    cst_objectid.common().member_id(memberId++);
    cst_objectid.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_objectid.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_objectid.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_objectid.common().member_flags().IS_OPTIONAL(false);
    cst_objectid.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_objectid.common().member_flags().IS_KEY(false);
    cst_objectid.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_objectid.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_objectid.detail().name("objectid");

    type_object->complete().struct_type().member_seq().emplace_back(cst_objectid);

    CompleteStructMember cst_type;
    cst_type.common().member_id(memberId++);
    cst_type.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_type.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_type.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_type.common().member_flags().IS_OPTIONAL(false);
    cst_type.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_type.common().member_flags().IS_KEY(false);
    cst_type.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_type.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_type.detail().name("type");

    type_object->complete().struct_type().member_seq().emplace_back(cst_type);

    CompleteStructMember cst_detectsensor_current;
    cst_detectsensor_current.common().member_id(memberId++);
    cst_detectsensor_current.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_detectsensor_current.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_detectsensor_current.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_detectsensor_current.common().member_flags().IS_OPTIONAL(false);
    cst_detectsensor_current.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_detectsensor_current.common().member_flags().IS_KEY(false);
    cst_detectsensor_current.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_detectsensor_current.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_detectsensor_current.detail().name("detectsensor_current");

    type_object->complete().struct_type().member_seq().emplace_back(cst_detectsensor_current);

    CompleteStructMember cst_detectsensor_history;
    cst_detectsensor_history.common().member_id(memberId++);
    cst_detectsensor_history.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_detectsensor_history.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_detectsensor_history.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_detectsensor_history.common().member_flags().IS_OPTIONAL(false);
    cst_detectsensor_history.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_detectsensor_history.common().member_flags().IS_KEY(false);
    cst_detectsensor_history.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_detectsensor_history.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_detectsensor_history.detail().name("detectsensor_history");

    type_object->complete().struct_type().member_seq().emplace_back(cst_detectsensor_history);

    CompleteStructMember cst_maintenancestatus;
    cst_maintenancestatus.common().member_id(memberId++);
    cst_maintenancestatus.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_maintenancestatus.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_maintenancestatus.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_maintenancestatus.common().member_flags().IS_OPTIONAL(false);
    cst_maintenancestatus.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_maintenancestatus.common().member_flags().IS_KEY(false);
    cst_maintenancestatus.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_maintenancestatus.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_maintenancestatus.detail().name("maintenancestatus");

    type_object->complete().struct_type().member_seq().emplace_back(cst_maintenancestatus);

    CompleteStructMember cst_typeconfidence;
    cst_typeconfidence.common().member_id(memberId++);
    cst_typeconfidence.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_typeconfidence.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_typeconfidence.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_typeconfidence.common().member_flags().IS_OPTIONAL(false);
    cst_typeconfidence.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_typeconfidence.common().member_flags().IS_KEY(false);
    cst_typeconfidence.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_typeconfidence.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    cst_typeconfidence.detail().name("typeconfidence");

    type_object->complete().struct_type().member_seq().emplace_back(cst_typeconfidence);

    CompleteStructMember cst_existenceprobability;
    cst_existenceprobability.common().member_id(memberId++);
    cst_existenceprobability.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_existenceprobability.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_existenceprobability.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_existenceprobability.common().member_flags().IS_OPTIONAL(false);
    cst_existenceprobability.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_existenceprobability.common().member_flags().IS_KEY(false);
    cst_existenceprobability.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_existenceprobability.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("float", false));

    cst_existenceprobability.detail().name("existenceprobability");

    type_object->complete().struct_type().member_seq().emplace_back(cst_existenceprobability);

    CompleteStructMember cst_rectinfo;
    cst_rectinfo.common().member_id(memberId++);
    cst_rectinfo.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_rectinfo.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_rectinfo.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_rectinfo.common().member_flags().IS_OPTIONAL(false);
    cst_rectinfo.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_rectinfo.common().member_flags().IS_KEY(false);
    cst_rectinfo.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_rectinfo.common().member_type_id(*GetAlgRect3DIdentifier(true));
    cst_rectinfo.detail().name("rectinfo");

    type_object->complete().struct_type().member_seq().emplace_back(cst_rectinfo);

    CompleteStructMember cst_velocityabs;
    cst_velocityabs.common().member_id(memberId++);
    cst_velocityabs.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_velocityabs.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_velocityabs.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_velocityabs.common().member_flags().IS_OPTIONAL(false);
    cst_velocityabs.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_velocityabs.common().member_flags().IS_KEY(false);
    cst_velocityabs.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_velocityabs.common().member_type_id(*GetPoint3DFloatIdentifier(true));
    cst_velocityabs.detail().name("velocityabs");

    type_object->complete().struct_type().member_seq().emplace_back(cst_velocityabs);

    CompleteStructMember cst_accelerationabs;
    cst_accelerationabs.common().member_id(memberId++);
    cst_accelerationabs.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_accelerationabs.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_accelerationabs.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_accelerationabs.common().member_flags().IS_OPTIONAL(false);
    cst_accelerationabs.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_accelerationabs.common().member_flags().IS_KEY(false);
    cst_accelerationabs.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_accelerationabs.common().member_type_id(*GetPoint3DFloatIdentifier(true));
    cst_accelerationabs.detail().name("accelerationabs");

    type_object->complete().struct_type().member_seq().emplace_back(cst_accelerationabs);

    CompleteStructMember cst_timecreation;
    cst_timecreation.common().member_id(memberId++);
    cst_timecreation.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_timecreation.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_timecreation.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_timecreation.common().member_flags().IS_OPTIONAL(false);
    cst_timecreation.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_timecreation.common().member_flags().IS_KEY(false);
    cst_timecreation.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_timecreation.common().member_type_id(*GetTimeIdentifier(true));
    cst_timecreation.detail().name("timecreation");

    type_object->complete().struct_type().member_seq().emplace_back(cst_timecreation);

    CompleteStructMember cst_lastupdatedtime;
    cst_lastupdatedtime.common().member_id(memberId++);
    cst_lastupdatedtime.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_lastupdatedtime.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_lastupdatedtime.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_lastupdatedtime.common().member_flags().IS_OPTIONAL(false);
    cst_lastupdatedtime.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_lastupdatedtime.common().member_flags().IS_KEY(false);
    cst_lastupdatedtime.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_lastupdatedtime.common().member_type_id(*GetTimeIdentifier(true));
    cst_lastupdatedtime.detail().name("lastupdatedtime");

    type_object->complete().struct_type().member_seq().emplace_back(cst_lastupdatedtime);

    CompleteStructMember cst_sensorid;
    cst_sensorid.common().member_id(memberId++);
    cst_sensorid.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_sensorid.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_sensorid.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_sensorid.common().member_flags().IS_OPTIONAL(false);
    cst_sensorid.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_sensorid.common().member_flags().IS_KEY(false);
    cst_sensorid.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_sensorid.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint32_t", 0, true));


    cst_sensorid.detail().name("sensorid");

    type_object->complete().struct_type().member_seq().emplace_back(cst_sensorid);

    CompleteStructMember cst_motionpattern;
    cst_motionpattern.common().member_id(memberId++);
    cst_motionpattern.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_motionpattern.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_motionpattern.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_motionpattern.common().member_flags().IS_OPTIONAL(false);
    cst_motionpattern.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_motionpattern.common().member_flags().IS_KEY(false);
    cst_motionpattern.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_motionpattern.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_motionpattern.detail().name("motionpattern");

    type_object->complete().struct_type().member_seq().emplace_back(cst_motionpattern);

    CompleteStructMember cst_motionpatternhistory;
    cst_motionpatternhistory.common().member_id(memberId++);
    cst_motionpatternhistory.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_motionpatternhistory.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_motionpatternhistory.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_motionpatternhistory.common().member_flags().IS_OPTIONAL(false);
    cst_motionpatternhistory.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_motionpatternhistory.common().member_flags().IS_KEY(false);
    cst_motionpatternhistory.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_motionpatternhistory.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_motionpatternhistory.detail().name("motionpatternhistory");

    type_object->complete().struct_type().member_seq().emplace_back(cst_motionpatternhistory);

    CompleteStructMember cst_brakelightst;
    cst_brakelightst.common().member_id(memberId++);
    cst_brakelightst.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_brakelightst.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_brakelightst.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_brakelightst.common().member_flags().IS_OPTIONAL(false);
    cst_brakelightst.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_brakelightst.common().member_flags().IS_KEY(false);
    cst_brakelightst.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_brakelightst.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_brakelightst.detail().name("brakelightst");

    type_object->complete().struct_type().member_seq().emplace_back(cst_brakelightst);

    CompleteStructMember cst_turnlightst;
    cst_turnlightst.common().member_id(memberId++);
    cst_turnlightst.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_turnlightst.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_turnlightst.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_turnlightst.common().member_flags().IS_OPTIONAL(false);
    cst_turnlightst.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_turnlightst.common().member_flags().IS_KEY(false);
    cst_turnlightst.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_turnlightst.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_turnlightst.detail().name("turnlightst");

    type_object->complete().struct_type().member_seq().emplace_back(cst_turnlightst);

    CompleteStructMember cst_nearside;
    cst_nearside.common().member_id(memberId++);
    cst_nearside.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_nearside.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_nearside.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_nearside.common().member_flags().IS_OPTIONAL(false);
    cst_nearside.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_nearside.common().member_flags().IS_KEY(false);
    cst_nearside.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_nearside.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_nearside.detail().name("nearside");

    type_object->complete().struct_type().member_seq().emplace_back(cst_nearside);

    CompleteStructMember cst_associatedconf;
    cst_associatedconf.common().member_id(memberId++);
    cst_associatedconf.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_associatedconf.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_associatedconf.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_associatedconf.common().member_flags().IS_OPTIONAL(false);
    cst_associatedconf.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_associatedconf.common().member_flags().IS_KEY(false);
    cst_associatedconf.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_associatedconf.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("float", 0, true));


    cst_associatedconf.detail().name("associatedconf");

    type_object->complete().struct_type().member_seq().emplace_back(cst_associatedconf);

    CompleteStructMember cst_age;
    cst_age.common().member_id(memberId++);
    cst_age.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_age.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_age.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_age.common().member_flags().IS_OPTIONAL(false);
    cst_age.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_age.common().member_flags().IS_KEY(false);
    cst_age.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_age.common().member_type_id(*TypeObjectFactory::get_instance()->get_type_identifier("uint32_t", false));

    cst_age.detail().name("age");

    type_object->complete().struct_type().member_seq().emplace_back(cst_age);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ObjectInfo");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ObjectInfo", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ObjectInfo", true);
}

const TypeIdentifier* GetObjectVecIdentifier(bool complete)
{
    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ObjectVec", complete);
    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
    {
        return c_identifier;
    }

    GetObjectVecObject(complete); // Generated inside
    return TypeObjectFactory::get_instance()->get_type_identifier("ObjectVec", complete);
}

const TypeObject* GetObjectVecObject(bool complete)
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ObjectVec", complete);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }
    else if (complete)
    {
        return GetCompleteObjectVecObject();
    }
    //else
    return GetMinimalObjectVecObject();
}

const TypeObject* GetMinimalObjectVecObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ObjectVec", false);
    if (c_type_object != nullptr)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_MINIMAL);
    type_object->minimal()._d(TK_STRUCTURE);

    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    MinimalStructMember mst_obj;
    mst_obj.common().member_id(memberId++);
    mst_obj.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    mst_obj.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    mst_obj.common().member_flags().IS_EXTERNAL(false); // Unsupported
    mst_obj.common().member_flags().IS_OPTIONAL(false);
    mst_obj.common().member_flags().IS_MUST_UNDERSTAND(false);
    mst_obj.common().member_flags().IS_KEY(false);
    mst_obj.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    mst_obj.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("ObjectInfo", 0, false));


    MD5 obj_hash("obj");
    for(int i = 0; i < 4; ++i)
    {
        mst_obj.detail().name_hash()[i] = obj_hash.digest[i];
    }
    type_object->minimal().struct_type().member_seq().emplace_back(mst_obj);


    // Header
    // TODO Inheritance
    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];

    TypeIdentifier identifier;
    identifier._d(EK_MINIMAL);

    SerializedPayload_t payload(static_cast<uint32_t>(
        MinimalStructType::getCdrSerializedSize(type_object->minimal().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ObjectVec", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ObjectVec", false);
}

const TypeObject* GetCompleteObjectVecObject()
{
    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ObjectVec", true);
    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
    {
        return c_type_object;
    }

    TypeObject *type_object = new TypeObject();
    type_object->_d(EK_COMPLETE);
    type_object->complete()._d(TK_STRUCTURE);

    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

    MemberId memberId = 0;
    CompleteStructMember cst_obj;
    cst_obj.common().member_id(memberId++);
    cst_obj.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
    cst_obj.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
    cst_obj.common().member_flags().IS_EXTERNAL(false); // Unsupported
    cst_obj.common().member_flags().IS_OPTIONAL(false);
    cst_obj.common().member_flags().IS_MUST_UNDERSTAND(false);
    cst_obj.common().member_flags().IS_KEY(false);
    cst_obj.common().member_flags().IS_DEFAULT(false); // Doesn't apply
    cst_obj.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("ObjectInfo", 0, true));


    cst_obj.detail().name("obj");

    type_object->complete().struct_type().member_seq().emplace_back(cst_obj);


    // Header
    type_object->complete().struct_type().header().detail().type_name("ObjectVec");
    // TODO inheritance


    TypeIdentifier identifier;
    identifier._d(EK_COMPLETE);

    SerializedPayload_t payload(static_cast<uint32_t>(
        CompleteStructType::getCdrSerializedSize(type_object->complete().struct_type()) + 4));
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
    eprosima::fastcdr::Cdr ser(
        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload.encapsulation = CDR_LE;

    type_object->serialize(ser);
    payload.length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    MD5 objectHash;
    objectHash.update((char*)payload.data, payload.length);
    objectHash.finalize();
    for(int i = 0; i < 14; ++i)
    {
        identifier.equivalence_hash()[i] = objectHash.digest[i];
    }

    TypeObjectFactory::get_instance()->add_type_object("ObjectVec", &identifier, type_object);
    delete type_object;
    return TypeObjectFactory::get_instance()->get_type_object("ObjectVec", true);
}
