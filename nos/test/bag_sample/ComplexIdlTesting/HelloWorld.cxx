// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file HelloWorld.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "HelloWorld.h"
#include "HelloWorldTypeObject.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

BaseHeader::BaseHeader()
{
    // m_seq com.eprosima.idl.parser.typecode.PrimitiveTypeCode@578486a3
    m_seq = 0;
    // m_data_timestamp_us com.eprosima.idl.parser.typecode.PrimitiveTypeCode@551aa95a
    m_data_timestamp_us = 0;
    // m_send_timestamp_us com.eprosima.idl.parser.typecode.PrimitiveTypeCode@35d176f7
    m_send_timestamp_us = 0;

    // Just to register all known types
    registerHelloWorldTypes();
}

BaseHeader::~BaseHeader()
{



}

BaseHeader::BaseHeader(
        const BaseHeader& x)
{
    m_seq = x.m_seq;
    m_data_timestamp_us = x.m_data_timestamp_us;
    m_send_timestamp_us = x.m_send_timestamp_us;
}

BaseHeader::BaseHeader(
        BaseHeader&& x) noexcept 
{
    m_seq = x.m_seq;
    m_data_timestamp_us = x.m_data_timestamp_us;
    m_send_timestamp_us = x.m_send_timestamp_us;
}

BaseHeader& BaseHeader::operator =(
        const BaseHeader& x)
{

    m_seq = x.m_seq;
    m_data_timestamp_us = x.m_data_timestamp_us;
    m_send_timestamp_us = x.m_send_timestamp_us;

    return *this;
}

BaseHeader& BaseHeader::operator =(
        BaseHeader&& x) noexcept
{

    m_seq = x.m_seq;
    m_data_timestamp_us = x.m_data_timestamp_us;
    m_send_timestamp_us = x.m_send_timestamp_us;

    return *this;
}

bool BaseHeader::operator ==(
        const BaseHeader& x) const
{

    return (m_seq == x.m_seq && m_data_timestamp_us == x.m_data_timestamp_us && m_send_timestamp_us == x.m_send_timestamp_us);
}

bool BaseHeader::operator !=(
        const BaseHeader& x) const
{
    return !(*this == x);
}

size_t BaseHeader::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t BaseHeader::getCdrSerializedSize(
        const BaseHeader& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void BaseHeader::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_seq;
    scdr << m_data_timestamp_us;
    scdr << m_send_timestamp_us;

}

void BaseHeader::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_seq;
    dcdr >> m_data_timestamp_us;
    dcdr >> m_send_timestamp_us;
}

/*!
 * @brief This function sets a value in member seq
 * @param _seq New value for member seq
 */
void BaseHeader::seq(
        uint32_t _seq)
{
    m_seq = _seq;
}

/*!
 * @brief This function returns the value of member seq
 * @return Value of member seq
 */
uint32_t BaseHeader::seq() const
{
    return m_seq;
}

/*!
 * @brief This function returns a reference to member seq
 * @return Reference to member seq
 */
uint32_t& BaseHeader::seq()
{
    return m_seq;
}

/*!
 * @brief This function sets a value in member data_timestamp_us
 * @param _data_timestamp_us New value for member data_timestamp_us
 */
void BaseHeader::data_timestamp_us(
        uint64_t _data_timestamp_us)
{
    m_data_timestamp_us = _data_timestamp_us;
}

/*!
 * @brief This function returns the value of member data_timestamp_us
 * @return Value of member data_timestamp_us
 */
uint64_t BaseHeader::data_timestamp_us() const
{
    return m_data_timestamp_us;
}

/*!
 * @brief This function returns a reference to member data_timestamp_us
 * @return Reference to member data_timestamp_us
 */
uint64_t& BaseHeader::data_timestamp_us()
{
    return m_data_timestamp_us;
}

/*!
 * @brief This function sets a value in member send_timestamp_us
 * @param _send_timestamp_us New value for member send_timestamp_us
 */
void BaseHeader::send_timestamp_us(
        uint64_t _send_timestamp_us)
{
    m_send_timestamp_us = _send_timestamp_us;
}

/*!
 * @brief This function returns the value of member send_timestamp_us
 * @return Value of member send_timestamp_us
 */
uint64_t BaseHeader::send_timestamp_us() const
{
    return m_send_timestamp_us;
}

/*!
 * @brief This function returns a reference to member send_timestamp_us
 * @return Reference to member send_timestamp_us
 */
uint64_t& BaseHeader::send_timestamp_us()
{
    return m_send_timestamp_us;
}


size_t BaseHeader::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;






    return current_align;
}

bool BaseHeader::isKeyDefined()
{
    return false;
}

void BaseHeader::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
       
}

Time::Time()
{
    // m_sec com.eprosima.idl.parser.typecode.PrimitiveTypeCode@49fc609f
    m_sec = 0;
    // m_nsec com.eprosima.idl.parser.typecode.PrimitiveTypeCode@cd2dae5
    m_nsec = 0;

    // Just to register all known types
    registerHelloWorldTypes();
}

Time::~Time()
{


}

Time::Time(
        const Time& x)
{
    m_sec = x.m_sec;
    m_nsec = x.m_nsec;
}

Time::Time(
        Time&& x) noexcept 
{
    m_sec = x.m_sec;
    m_nsec = x.m_nsec;
}

Time& Time::operator =(
        const Time& x)
{

    m_sec = x.m_sec;
    m_nsec = x.m_nsec;

    return *this;
}

Time& Time::operator =(
        Time&& x) noexcept
{

    m_sec = x.m_sec;
    m_nsec = x.m_nsec;

    return *this;
}

bool Time::operator ==(
        const Time& x) const
{

    return (m_sec == x.m_sec && m_nsec == x.m_nsec);
}

bool Time::operator !=(
        const Time& x) const
{
    return !(*this == x);
}

size_t Time::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t Time::getCdrSerializedSize(
        const Time& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void Time::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_sec;
    scdr << m_nsec;

}

void Time::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_sec;
    dcdr >> m_nsec;
}

/*!
 * @brief This function sets a value in member sec
 * @param _sec New value for member sec
 */
void Time::sec(
        uint64_t _sec)
{
    m_sec = _sec;
}

/*!
 * @brief This function returns the value of member sec
 * @return Value of member sec
 */
uint64_t Time::sec() const
{
    return m_sec;
}

/*!
 * @brief This function returns a reference to member sec
 * @return Reference to member sec
 */
uint64_t& Time::sec()
{
    return m_sec;
}

/*!
 * @brief This function sets a value in member nsec
 * @param _nsec New value for member nsec
 */
void Time::nsec(
        uint64_t _nsec)
{
    m_nsec = _nsec;
}

/*!
 * @brief This function returns the value of member nsec
 * @return Value of member nsec
 */
uint64_t Time::nsec() const
{
    return m_nsec;
}

/*!
 * @brief This function returns a reference to member nsec
 * @return Reference to member nsec
 */
uint64_t& Time::nsec()
{
    return m_nsec;
}


size_t Time::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool Time::isKeyDefined()
{
    return false;
}

void Time::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

Point3DFloat::Point3DFloat()
{
    // m_x com.eprosima.idl.parser.typecode.PrimitiveTypeCode@63e2203c
    m_x = 0.0;
    // m_y com.eprosima.idl.parser.typecode.PrimitiveTypeCode@6737fd8f
    m_y = 0.0;
    // m_z com.eprosima.idl.parser.typecode.PrimitiveTypeCode@72b6cbcc
    m_z = 0.0;

    // Just to register all known types
    registerHelloWorldTypes();
}

Point3DFloat::~Point3DFloat()
{



}

Point3DFloat::Point3DFloat(
        const Point3DFloat& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
}

Point3DFloat::Point3DFloat(
        Point3DFloat&& x) noexcept 
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
}

Point3DFloat& Point3DFloat::operator =(
        const Point3DFloat& x)
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;

    return *this;
}

Point3DFloat& Point3DFloat::operator =(
        Point3DFloat&& x) noexcept
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;

    return *this;
}

bool Point3DFloat::operator ==(
        const Point3DFloat& x) const
{

    return (m_x == x.m_x && m_y == x.m_y && m_z == x.m_z);
}

bool Point3DFloat::operator !=(
        const Point3DFloat& x) const
{
    return !(*this == x);
}

size_t Point3DFloat::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t Point3DFloat::getCdrSerializedSize(
        const Point3DFloat& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void Point3DFloat::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_x;
    scdr << m_y;
    scdr << m_z;

}

void Point3DFloat::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_x;
    dcdr >> m_y;
    dcdr >> m_z;
}

/*!
 * @brief This function sets a value in member x
 * @param _x New value for member x
 */
void Point3DFloat::x(
        float _x)
{
    m_x = _x;
}

/*!
 * @brief This function returns the value of member x
 * @return Value of member x
 */
float Point3DFloat::x() const
{
    return m_x;
}

/*!
 * @brief This function returns a reference to member x
 * @return Reference to member x
 */
float& Point3DFloat::x()
{
    return m_x;
}

/*!
 * @brief This function sets a value in member y
 * @param _y New value for member y
 */
void Point3DFloat::y(
        float _y)
{
    m_y = _y;
}

/*!
 * @brief This function returns the value of member y
 * @return Value of member y
 */
float Point3DFloat::y() const
{
    return m_y;
}

/*!
 * @brief This function returns a reference to member y
 * @return Reference to member y
 */
float& Point3DFloat::y()
{
    return m_y;
}

/*!
 * @brief This function sets a value in member z
 * @param _z New value for member z
 */
void Point3DFloat::z(
        float _z)
{
    m_z = _z;
}

/*!
 * @brief This function returns the value of member z
 * @return Value of member z
 */
float Point3DFloat::z() const
{
    return m_z;
}

/*!
 * @brief This function returns a reference to member z
 * @return Reference to member z
 */
float& Point3DFloat::z()
{
    return m_z;
}


size_t Point3DFloat::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;






    return current_align;
}

bool Point3DFloat::isKeyDefined()
{
    return false;
}

void Point3DFloat::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
       
}

Point3DDouble::Point3DDouble()
{
    // m_x com.eprosima.idl.parser.typecode.PrimitiveTypeCode@9660f4e
    m_x = 0.0;
    // m_y com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5a8806ef
    m_y = 0.0;
    // m_z com.eprosima.idl.parser.typecode.PrimitiveTypeCode@6c49835d
    m_z = 0.0;

    // Just to register all known types
    registerHelloWorldTypes();
}

Point3DDouble::~Point3DDouble()
{



}

Point3DDouble::Point3DDouble(
        const Point3DDouble& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
}

Point3DDouble::Point3DDouble(
        Point3DDouble&& x) noexcept 
{
    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;
}

Point3DDouble& Point3DDouble::operator =(
        const Point3DDouble& x)
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;

    return *this;
}

Point3DDouble& Point3DDouble::operator =(
        Point3DDouble&& x) noexcept
{

    m_x = x.m_x;
    m_y = x.m_y;
    m_z = x.m_z;

    return *this;
}

bool Point3DDouble::operator ==(
        const Point3DDouble& x) const
{

    return (m_x == x.m_x && m_y == x.m_y && m_z == x.m_z);
}

bool Point3DDouble::operator !=(
        const Point3DDouble& x) const
{
    return !(*this == x);
}

size_t Point3DDouble::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t Point3DDouble::getCdrSerializedSize(
        const Point3DDouble& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void Point3DDouble::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_x;
    scdr << m_y;
    scdr << m_z;

}

void Point3DDouble::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_x;
    dcdr >> m_y;
    dcdr >> m_z;
}

/*!
 * @brief This function sets a value in member x
 * @param _x New value for member x
 */
void Point3DDouble::x(
        double _x)
{
    m_x = _x;
}

/*!
 * @brief This function returns the value of member x
 * @return Value of member x
 */
double Point3DDouble::x() const
{
    return m_x;
}

/*!
 * @brief This function returns a reference to member x
 * @return Reference to member x
 */
double& Point3DDouble::x()
{
    return m_x;
}

/*!
 * @brief This function sets a value in member y
 * @param _y New value for member y
 */
void Point3DDouble::y(
        double _y)
{
    m_y = _y;
}

/*!
 * @brief This function returns the value of member y
 * @return Value of member y
 */
double Point3DDouble::y() const
{
    return m_y;
}

/*!
 * @brief This function returns a reference to member y
 * @return Reference to member y
 */
double& Point3DDouble::y()
{
    return m_y;
}

/*!
 * @brief This function sets a value in member z
 * @param _z New value for member z
 */
void Point3DDouble::z(
        double _z)
{
    m_z = _z;
}

/*!
 * @brief This function returns the value of member z
 * @return Value of member z
 */
double Point3DDouble::z() const
{
    return m_z;
}

/*!
 * @brief This function returns a reference to member z
 * @return Reference to member z
 */
double& Point3DDouble::z()
{
    return m_z;
}


size_t Point3DDouble::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;






    return current_align;
}

bool Point3DDouble::isKeyDefined()
{
    return false;
}

void Point3DDouble::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
       
}

AlgRect3D::AlgRect3D()
{
    // m_center com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@18bf3d14

    // m_centerstddev com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@4fb64261

    // m_sizelwh com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@18bf3d14

    // m_sizestddev com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@4fb64261

    // m_orientation com.eprosima.idl.parser.typecode.PrimitiveTypeCode@782663d3
    m_orientation = 0.0;
    // m_orientationstddev com.eprosima.idl.parser.typecode.PrimitiveTypeCode@1990a65e
    m_orientationstddev = 0.0;
    // m_corners com.eprosima.idl.parser.typecode.SequenceTypeCode@64485a47


    // Just to register all known types
    registerHelloWorldTypes();
}

AlgRect3D::~AlgRect3D()
{







}

AlgRect3D::AlgRect3D(
        const AlgRect3D& x)
{
    m_center = x.m_center;
    m_centerstddev = x.m_centerstddev;
    m_sizelwh = x.m_sizelwh;
    m_sizestddev = x.m_sizestddev;
    m_orientation = x.m_orientation;
    m_orientationstddev = x.m_orientationstddev;
    m_corners = x.m_corners;
}

AlgRect3D::AlgRect3D(
        AlgRect3D&& x) noexcept 
{
    m_center = std::move(x.m_center);
    m_centerstddev = std::move(x.m_centerstddev);
    m_sizelwh = std::move(x.m_sizelwh);
    m_sizestddev = std::move(x.m_sizestddev);
    m_orientation = x.m_orientation;
    m_orientationstddev = x.m_orientationstddev;
    m_corners = std::move(x.m_corners);
}

AlgRect3D& AlgRect3D::operator =(
        const AlgRect3D& x)
{

    m_center = x.m_center;
    m_centerstddev = x.m_centerstddev;
    m_sizelwh = x.m_sizelwh;
    m_sizestddev = x.m_sizestddev;
    m_orientation = x.m_orientation;
    m_orientationstddev = x.m_orientationstddev;
    m_corners = x.m_corners;

    return *this;
}

AlgRect3D& AlgRect3D::operator =(
        AlgRect3D&& x) noexcept
{

    m_center = std::move(x.m_center);
    m_centerstddev = std::move(x.m_centerstddev);
    m_sizelwh = std::move(x.m_sizelwh);
    m_sizestddev = std::move(x.m_sizestddev);
    m_orientation = x.m_orientation;
    m_orientationstddev = x.m_orientationstddev;
    m_corners = std::move(x.m_corners);

    return *this;
}

bool AlgRect3D::operator ==(
        const AlgRect3D& x) const
{

    return (m_center == x.m_center && m_centerstddev == x.m_centerstddev && m_sizelwh == x.m_sizelwh && m_sizestddev == x.m_sizestddev && m_orientation == x.m_orientation && m_orientationstddev == x.m_orientationstddev && m_corners == x.m_corners);
}

bool AlgRect3D::operator !=(
        const AlgRect3D& x) const
{
    return !(*this == x);
}

size_t AlgRect3D::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += Point3DFloat::getMaxCdrSerializedSize(current_alignment);
    current_alignment += Point3DDouble::getMaxCdrSerializedSize(current_alignment);
    current_alignment += Point3DFloat::getMaxCdrSerializedSize(current_alignment);
    current_alignment += Point3DDouble::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += Point3DFloat::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t AlgRect3D::getCdrSerializedSize(
        const AlgRect3D& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += Point3DFloat::getCdrSerializedSize(data.center(), current_alignment);
    current_alignment += Point3DDouble::getCdrSerializedSize(data.centerstddev(), current_alignment);
    current_alignment += Point3DFloat::getCdrSerializedSize(data.sizelwh(), current_alignment);
    current_alignment += Point3DDouble::getCdrSerializedSize(data.sizestddev(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.corners().size(); ++a)
    {
        current_alignment += Point3DFloat::getCdrSerializedSize(data.corners().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void AlgRect3D::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_center;
    scdr << m_centerstddev;
    scdr << m_sizelwh;
    scdr << m_sizestddev;
    scdr << m_orientation;
    scdr << m_orientationstddev;
    scdr << m_corners;

}

void AlgRect3D::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_center;
    dcdr >> m_centerstddev;
    dcdr >> m_sizelwh;
    dcdr >> m_sizestddev;
    dcdr >> m_orientation;
    dcdr >> m_orientationstddev;
    dcdr >> m_corners;
}

/*!
 * @brief This function copies the value in member center
 * @param _center New value to be copied in member center
 */
void AlgRect3D::center(
        const Point3DFloat& _center)
{
    m_center = _center;
}

/*!
 * @brief This function moves the value in member center
 * @param _center New value to be moved in member center
 */
void AlgRect3D::center(
        Point3DFloat&& _center)
{
    m_center = std::move(_center);
}

/*!
 * @brief This function returns a constant reference to member center
 * @return Constant reference to member center
 */
const Point3DFloat& AlgRect3D::center() const
{
    return m_center;
}

/*!
 * @brief This function returns a reference to member center
 * @return Reference to member center
 */
Point3DFloat& AlgRect3D::center()
{
    return m_center;
}
/*!
 * @brief This function copies the value in member centerstddev
 * @param _centerstddev New value to be copied in member centerstddev
 */
void AlgRect3D::centerstddev(
        const Point3DDouble& _centerstddev)
{
    m_centerstddev = _centerstddev;
}

/*!
 * @brief This function moves the value in member centerstddev
 * @param _centerstddev New value to be moved in member centerstddev
 */
void AlgRect3D::centerstddev(
        Point3DDouble&& _centerstddev)
{
    m_centerstddev = std::move(_centerstddev);
}

/*!
 * @brief This function returns a constant reference to member centerstddev
 * @return Constant reference to member centerstddev
 */
const Point3DDouble& AlgRect3D::centerstddev() const
{
    return m_centerstddev;
}

/*!
 * @brief This function returns a reference to member centerstddev
 * @return Reference to member centerstddev
 */
Point3DDouble& AlgRect3D::centerstddev()
{
    return m_centerstddev;
}
/*!
 * @brief This function copies the value in member sizelwh
 * @param _sizelwh New value to be copied in member sizelwh
 */
void AlgRect3D::sizelwh(
        const Point3DFloat& _sizelwh)
{
    m_sizelwh = _sizelwh;
}

/*!
 * @brief This function moves the value in member sizelwh
 * @param _sizelwh New value to be moved in member sizelwh
 */
void AlgRect3D::sizelwh(
        Point3DFloat&& _sizelwh)
{
    m_sizelwh = std::move(_sizelwh);
}

/*!
 * @brief This function returns a constant reference to member sizelwh
 * @return Constant reference to member sizelwh
 */
const Point3DFloat& AlgRect3D::sizelwh() const
{
    return m_sizelwh;
}

/*!
 * @brief This function returns a reference to member sizelwh
 * @return Reference to member sizelwh
 */
Point3DFloat& AlgRect3D::sizelwh()
{
    return m_sizelwh;
}
/*!
 * @brief This function copies the value in member sizestddev
 * @param _sizestddev New value to be copied in member sizestddev
 */
void AlgRect3D::sizestddev(
        const Point3DDouble& _sizestddev)
{
    m_sizestddev = _sizestddev;
}

/*!
 * @brief This function moves the value in member sizestddev
 * @param _sizestddev New value to be moved in member sizestddev
 */
void AlgRect3D::sizestddev(
        Point3DDouble&& _sizestddev)
{
    m_sizestddev = std::move(_sizestddev);
}

/*!
 * @brief This function returns a constant reference to member sizestddev
 * @return Constant reference to member sizestddev
 */
const Point3DDouble& AlgRect3D::sizestddev() const
{
    return m_sizestddev;
}

/*!
 * @brief This function returns a reference to member sizestddev
 * @return Reference to member sizestddev
 */
Point3DDouble& AlgRect3D::sizestddev()
{
    return m_sizestddev;
}
/*!
 * @brief This function sets a value in member orientation
 * @param _orientation New value for member orientation
 */
void AlgRect3D::orientation(
        double _orientation)
{
    m_orientation = _orientation;
}

/*!
 * @brief This function returns the value of member orientation
 * @return Value of member orientation
 */
double AlgRect3D::orientation() const
{
    return m_orientation;
}

/*!
 * @brief This function returns a reference to member orientation
 * @return Reference to member orientation
 */
double& AlgRect3D::orientation()
{
    return m_orientation;
}

/*!
 * @brief This function sets a value in member orientationstddev
 * @param _orientationstddev New value for member orientationstddev
 */
void AlgRect3D::orientationstddev(
        double _orientationstddev)
{
    m_orientationstddev = _orientationstddev;
}

/*!
 * @brief This function returns the value of member orientationstddev
 * @return Value of member orientationstddev
 */
double AlgRect3D::orientationstddev() const
{
    return m_orientationstddev;
}

/*!
 * @brief This function returns a reference to member orientationstddev
 * @return Reference to member orientationstddev
 */
double& AlgRect3D::orientationstddev()
{
    return m_orientationstddev;
}

/*!
 * @brief This function copies the value in member corners
 * @param _corners New value to be copied in member corners
 */
void AlgRect3D::corners(
        const std::vector<Point3DFloat>& _corners)
{
    m_corners = _corners;
}

/*!
 * @brief This function moves the value in member corners
 * @param _corners New value to be moved in member corners
 */
void AlgRect3D::corners(
        std::vector<Point3DFloat>&& _corners)
{
    m_corners = std::move(_corners);
}

/*!
 * @brief This function returns a constant reference to member corners
 * @return Constant reference to member corners
 */
const std::vector<Point3DFloat>& AlgRect3D::corners() const
{
    return m_corners;
}

/*!
 * @brief This function returns a reference to member corners
 * @return Reference to member corners
 */
std::vector<Point3DFloat>& AlgRect3D::corners()
{
    return m_corners;
}

size_t AlgRect3D::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;










    return current_align;
}

bool AlgRect3D::isKeyDefined()
{
    return false;
}

void AlgRect3D::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
           
}

ObjectInfo::ObjectInfo()
{
    // m_header com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@10dba097

    // m_objectid com.eprosima.idl.parser.typecode.PrimitiveTypeCode@1786f9d5
    m_objectid = 0;
    // m_type com.eprosima.idl.parser.typecode.PrimitiveTypeCode@704d6e83
    m_type = 0;
    // m_detectsensor_current com.eprosima.idl.parser.typecode.PrimitiveTypeCode@43a0cee9
    m_detectsensor_current = 0;
    // m_detectsensor_history com.eprosima.idl.parser.typecode.PrimitiveTypeCode@3578436e
    m_detectsensor_history = 0;
    // m_maintenancestatus com.eprosima.idl.parser.typecode.PrimitiveTypeCode@706a04ae
    m_maintenancestatus = 0;
    // m_typeconfidence com.eprosima.idl.parser.typecode.PrimitiveTypeCode@6eceb130
    m_typeconfidence = 0.0;
    // m_existenceprobability com.eprosima.idl.parser.typecode.PrimitiveTypeCode@10a035a0
    m_existenceprobability = 0.0;
    // m_rectinfo com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@67b467e9

    // m_velocityabs com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@18bf3d14

    // m_accelerationabs com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@18bf3d14

    // m_timecreation com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@47db50c5

    // m_lastupdatedtime com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@47db50c5

    // m_sensorid com.eprosima.idl.parser.typecode.SequenceTypeCode@5c072e3f

    // m_motionpattern com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4d1b0d2a
    m_motionpattern = 0;
    // m_motionpatternhistory com.eprosima.idl.parser.typecode.PrimitiveTypeCode@954b04f
    m_motionpatternhistory = 0;
    // m_brakelightst com.eprosima.idl.parser.typecode.PrimitiveTypeCode@149494d8
    m_brakelightst = 0;
    // m_turnlightst com.eprosima.idl.parser.typecode.PrimitiveTypeCode@710726a3
    m_turnlightst = 0;
    // m_nearside com.eprosima.idl.parser.typecode.PrimitiveTypeCode@646007f4
    m_nearside = 0;
    // m_associatedconf com.eprosima.idl.parser.typecode.SequenceTypeCode@481a15ff

    // m_age com.eprosima.idl.parser.typecode.PrimitiveTypeCode@78186a70
    m_age = 0;

    // Just to register all known types
    registerHelloWorldTypes();
}

ObjectInfo::~ObjectInfo()
{





















}

ObjectInfo::ObjectInfo(
        const ObjectInfo& x)
{
    m_header = x.m_header;
    m_objectid = x.m_objectid;
    m_type = x.m_type;
    m_detectsensor_current = x.m_detectsensor_current;
    m_detectsensor_history = x.m_detectsensor_history;
    m_maintenancestatus = x.m_maintenancestatus;
    m_typeconfidence = x.m_typeconfidence;
    m_existenceprobability = x.m_existenceprobability;
    m_rectinfo = x.m_rectinfo;
    m_velocityabs = x.m_velocityabs;
    m_accelerationabs = x.m_accelerationabs;
    m_timecreation = x.m_timecreation;
    m_lastupdatedtime = x.m_lastupdatedtime;
    m_sensorid = x.m_sensorid;
    m_motionpattern = x.m_motionpattern;
    m_motionpatternhistory = x.m_motionpatternhistory;
    m_brakelightst = x.m_brakelightst;
    m_turnlightst = x.m_turnlightst;
    m_nearside = x.m_nearside;
    m_associatedconf = x.m_associatedconf;
    m_age = x.m_age;
}

ObjectInfo::ObjectInfo(
        ObjectInfo&& x) noexcept 
{
    m_header = std::move(x.m_header);
    m_objectid = x.m_objectid;
    m_type = x.m_type;
    m_detectsensor_current = x.m_detectsensor_current;
    m_detectsensor_history = x.m_detectsensor_history;
    m_maintenancestatus = x.m_maintenancestatus;
    m_typeconfidence = x.m_typeconfidence;
    m_existenceprobability = x.m_existenceprobability;
    m_rectinfo = std::move(x.m_rectinfo);
    m_velocityabs = std::move(x.m_velocityabs);
    m_accelerationabs = std::move(x.m_accelerationabs);
    m_timecreation = std::move(x.m_timecreation);
    m_lastupdatedtime = std::move(x.m_lastupdatedtime);
    m_sensorid = std::move(x.m_sensorid);
    m_motionpattern = x.m_motionpattern;
    m_motionpatternhistory = x.m_motionpatternhistory;
    m_brakelightst = x.m_brakelightst;
    m_turnlightst = x.m_turnlightst;
    m_nearside = x.m_nearside;
    m_associatedconf = std::move(x.m_associatedconf);
    m_age = x.m_age;
}

ObjectInfo& ObjectInfo::operator =(
        const ObjectInfo& x)
{

    m_header = x.m_header;
    m_objectid = x.m_objectid;
    m_type = x.m_type;
    m_detectsensor_current = x.m_detectsensor_current;
    m_detectsensor_history = x.m_detectsensor_history;
    m_maintenancestatus = x.m_maintenancestatus;
    m_typeconfidence = x.m_typeconfidence;
    m_existenceprobability = x.m_existenceprobability;
    m_rectinfo = x.m_rectinfo;
    m_velocityabs = x.m_velocityabs;
    m_accelerationabs = x.m_accelerationabs;
    m_timecreation = x.m_timecreation;
    m_lastupdatedtime = x.m_lastupdatedtime;
    m_sensorid = x.m_sensorid;
    m_motionpattern = x.m_motionpattern;
    m_motionpatternhistory = x.m_motionpatternhistory;
    m_brakelightst = x.m_brakelightst;
    m_turnlightst = x.m_turnlightst;
    m_nearside = x.m_nearside;
    m_associatedconf = x.m_associatedconf;
    m_age = x.m_age;

    return *this;
}

ObjectInfo& ObjectInfo::operator =(
        ObjectInfo&& x) noexcept
{

    m_header = std::move(x.m_header);
    m_objectid = x.m_objectid;
    m_type = x.m_type;
    m_detectsensor_current = x.m_detectsensor_current;
    m_detectsensor_history = x.m_detectsensor_history;
    m_maintenancestatus = x.m_maintenancestatus;
    m_typeconfidence = x.m_typeconfidence;
    m_existenceprobability = x.m_existenceprobability;
    m_rectinfo = std::move(x.m_rectinfo);
    m_velocityabs = std::move(x.m_velocityabs);
    m_accelerationabs = std::move(x.m_accelerationabs);
    m_timecreation = std::move(x.m_timecreation);
    m_lastupdatedtime = std::move(x.m_lastupdatedtime);
    m_sensorid = std::move(x.m_sensorid);
    m_motionpattern = x.m_motionpattern;
    m_motionpatternhistory = x.m_motionpatternhistory;
    m_brakelightst = x.m_brakelightst;
    m_turnlightst = x.m_turnlightst;
    m_nearside = x.m_nearside;
    m_associatedconf = std::move(x.m_associatedconf);
    m_age = x.m_age;

    return *this;
}

bool ObjectInfo::operator ==(
        const ObjectInfo& x) const
{

    return (m_header == x.m_header && m_objectid == x.m_objectid && m_type == x.m_type && m_detectsensor_current == x.m_detectsensor_current && m_detectsensor_history == x.m_detectsensor_history && m_maintenancestatus == x.m_maintenancestatus && m_typeconfidence == x.m_typeconfidence && m_existenceprobability == x.m_existenceprobability && m_rectinfo == x.m_rectinfo && m_velocityabs == x.m_velocityabs && m_accelerationabs == x.m_accelerationabs && m_timecreation == x.m_timecreation && m_lastupdatedtime == x.m_lastupdatedtime && m_sensorid == x.m_sensorid && m_motionpattern == x.m_motionpattern && m_motionpatternhistory == x.m_motionpatternhistory && m_brakelightst == x.m_brakelightst && m_turnlightst == x.m_turnlightst && m_nearside == x.m_nearside && m_associatedconf == x.m_associatedconf && m_age == x.m_age);
}

bool ObjectInfo::operator !=(
        const ObjectInfo& x) const
{
    return !(*this == x);
}

size_t ObjectInfo::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += BaseHeader::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += AlgRect3D::getMaxCdrSerializedSize(current_alignment);
    current_alignment += Point3DFloat::getMaxCdrSerializedSize(current_alignment);
    current_alignment += Point3DFloat::getMaxCdrSerializedSize(current_alignment);
    current_alignment += Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += Time::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (100 * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (100 * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t ObjectInfo::getCdrSerializedSize(
        const ObjectInfo& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += BaseHeader::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += AlgRect3D::getCdrSerializedSize(data.rectinfo(), current_alignment);
    current_alignment += Point3DFloat::getCdrSerializedSize(data.velocityabs(), current_alignment);
    current_alignment += Point3DFloat::getCdrSerializedSize(data.accelerationabs(), current_alignment);
    current_alignment += Time::getCdrSerializedSize(data.timecreation(), current_alignment);
    current_alignment += Time::getCdrSerializedSize(data.lastupdatedtime(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.sensorid().size() > 0)
    {
        current_alignment += (data.sensorid().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.associatedconf().size() > 0)
    {
        current_alignment += (data.associatedconf().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void ObjectInfo::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_objectid;
    scdr << m_type;
    scdr << m_detectsensor_current;
    scdr << m_detectsensor_history;
    scdr << m_maintenancestatus;
    scdr << m_typeconfidence;
    scdr << m_existenceprobability;
    scdr << m_rectinfo;
    scdr << m_velocityabs;
    scdr << m_accelerationabs;
    scdr << m_timecreation;
    scdr << m_lastupdatedtime;
    scdr << m_sensorid;
    scdr << m_motionpattern;
    scdr << m_motionpatternhistory;
    scdr << m_brakelightst;
    scdr << m_turnlightst;
    scdr << m_nearside;
    scdr << m_associatedconf;
    scdr << m_age;

}

void ObjectInfo::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_objectid;
    dcdr >> m_type;
    dcdr >> m_detectsensor_current;
    dcdr >> m_detectsensor_history;
    dcdr >> m_maintenancestatus;
    dcdr >> m_typeconfidence;
    dcdr >> m_existenceprobability;
    dcdr >> m_rectinfo;
    dcdr >> m_velocityabs;
    dcdr >> m_accelerationabs;
    dcdr >> m_timecreation;
    dcdr >> m_lastupdatedtime;
    dcdr >> m_sensorid;
    dcdr >> m_motionpattern;
    dcdr >> m_motionpatternhistory;
    dcdr >> m_brakelightst;
    dcdr >> m_turnlightst;
    dcdr >> m_nearside;
    dcdr >> m_associatedconf;
    dcdr >> m_age;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void ObjectInfo::header(
        const BaseHeader& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void ObjectInfo::header(
        BaseHeader&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const BaseHeader& ObjectInfo::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
BaseHeader& ObjectInfo::header()
{
    return m_header;
}
/*!
 * @brief This function sets a value in member objectid
 * @param _objectid New value for member objectid
 */
void ObjectInfo::objectid(
        uint32_t _objectid)
{
    m_objectid = _objectid;
}

/*!
 * @brief This function returns the value of member objectid
 * @return Value of member objectid
 */
uint32_t ObjectInfo::objectid() const
{
    return m_objectid;
}

/*!
 * @brief This function returns a reference to member objectid
 * @return Reference to member objectid
 */
uint32_t& ObjectInfo::objectid()
{
    return m_objectid;
}

/*!
 * @brief This function sets a value in member type
 * @param _type New value for member type
 */
void ObjectInfo::type(
        uint32_t _type)
{
    m_type = _type;
}

/*!
 * @brief This function returns the value of member type
 * @return Value of member type
 */
uint32_t ObjectInfo::type() const
{
    return m_type;
}

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
uint32_t& ObjectInfo::type()
{
    return m_type;
}

/*!
 * @brief This function sets a value in member detectsensor_current
 * @param _detectsensor_current New value for member detectsensor_current
 */
void ObjectInfo::detectsensor_current(
        uint32_t _detectsensor_current)
{
    m_detectsensor_current = _detectsensor_current;
}

/*!
 * @brief This function returns the value of member detectsensor_current
 * @return Value of member detectsensor_current
 */
uint32_t ObjectInfo::detectsensor_current() const
{
    return m_detectsensor_current;
}

/*!
 * @brief This function returns a reference to member detectsensor_current
 * @return Reference to member detectsensor_current
 */
uint32_t& ObjectInfo::detectsensor_current()
{
    return m_detectsensor_current;
}

/*!
 * @brief This function sets a value in member detectsensor_history
 * @param _detectsensor_history New value for member detectsensor_history
 */
void ObjectInfo::detectsensor_history(
        uint32_t _detectsensor_history)
{
    m_detectsensor_history = _detectsensor_history;
}

/*!
 * @brief This function returns the value of member detectsensor_history
 * @return Value of member detectsensor_history
 */
uint32_t ObjectInfo::detectsensor_history() const
{
    return m_detectsensor_history;
}

/*!
 * @brief This function returns a reference to member detectsensor_history
 * @return Reference to member detectsensor_history
 */
uint32_t& ObjectInfo::detectsensor_history()
{
    return m_detectsensor_history;
}

/*!
 * @brief This function sets a value in member maintenancestatus
 * @param _maintenancestatus New value for member maintenancestatus
 */
void ObjectInfo::maintenancestatus(
        uint32_t _maintenancestatus)
{
    m_maintenancestatus = _maintenancestatus;
}

/*!
 * @brief This function returns the value of member maintenancestatus
 * @return Value of member maintenancestatus
 */
uint32_t ObjectInfo::maintenancestatus() const
{
    return m_maintenancestatus;
}

/*!
 * @brief This function returns a reference to member maintenancestatus
 * @return Reference to member maintenancestatus
 */
uint32_t& ObjectInfo::maintenancestatus()
{
    return m_maintenancestatus;
}

/*!
 * @brief This function sets a value in member typeconfidence
 * @param _typeconfidence New value for member typeconfidence
 */
void ObjectInfo::typeconfidence(
        float _typeconfidence)
{
    m_typeconfidence = _typeconfidence;
}

/*!
 * @brief This function returns the value of member typeconfidence
 * @return Value of member typeconfidence
 */
float ObjectInfo::typeconfidence() const
{
    return m_typeconfidence;
}

/*!
 * @brief This function returns a reference to member typeconfidence
 * @return Reference to member typeconfidence
 */
float& ObjectInfo::typeconfidence()
{
    return m_typeconfidence;
}

/*!
 * @brief This function sets a value in member existenceprobability
 * @param _existenceprobability New value for member existenceprobability
 */
void ObjectInfo::existenceprobability(
        float _existenceprobability)
{
    m_existenceprobability = _existenceprobability;
}

/*!
 * @brief This function returns the value of member existenceprobability
 * @return Value of member existenceprobability
 */
float ObjectInfo::existenceprobability() const
{
    return m_existenceprobability;
}

/*!
 * @brief This function returns a reference to member existenceprobability
 * @return Reference to member existenceprobability
 */
float& ObjectInfo::existenceprobability()
{
    return m_existenceprobability;
}

/*!
 * @brief This function copies the value in member rectinfo
 * @param _rectinfo New value to be copied in member rectinfo
 */
void ObjectInfo::rectinfo(
        const AlgRect3D& _rectinfo)
{
    m_rectinfo = _rectinfo;
}

/*!
 * @brief This function moves the value in member rectinfo
 * @param _rectinfo New value to be moved in member rectinfo
 */
void ObjectInfo::rectinfo(
        AlgRect3D&& _rectinfo)
{
    m_rectinfo = std::move(_rectinfo);
}

/*!
 * @brief This function returns a constant reference to member rectinfo
 * @return Constant reference to member rectinfo
 */
const AlgRect3D& ObjectInfo::rectinfo() const
{
    return m_rectinfo;
}

/*!
 * @brief This function returns a reference to member rectinfo
 * @return Reference to member rectinfo
 */
AlgRect3D& ObjectInfo::rectinfo()
{
    return m_rectinfo;
}
/*!
 * @brief This function copies the value in member velocityabs
 * @param _velocityabs New value to be copied in member velocityabs
 */
void ObjectInfo::velocityabs(
        const Point3DFloat& _velocityabs)
{
    m_velocityabs = _velocityabs;
}

/*!
 * @brief This function moves the value in member velocityabs
 * @param _velocityabs New value to be moved in member velocityabs
 */
void ObjectInfo::velocityabs(
        Point3DFloat&& _velocityabs)
{
    m_velocityabs = std::move(_velocityabs);
}

/*!
 * @brief This function returns a constant reference to member velocityabs
 * @return Constant reference to member velocityabs
 */
const Point3DFloat& ObjectInfo::velocityabs() const
{
    return m_velocityabs;
}

/*!
 * @brief This function returns a reference to member velocityabs
 * @return Reference to member velocityabs
 */
Point3DFloat& ObjectInfo::velocityabs()
{
    return m_velocityabs;
}
/*!
 * @brief This function copies the value in member accelerationabs
 * @param _accelerationabs New value to be copied in member accelerationabs
 */
void ObjectInfo::accelerationabs(
        const Point3DFloat& _accelerationabs)
{
    m_accelerationabs = _accelerationabs;
}

/*!
 * @brief This function moves the value in member accelerationabs
 * @param _accelerationabs New value to be moved in member accelerationabs
 */
void ObjectInfo::accelerationabs(
        Point3DFloat&& _accelerationabs)
{
    m_accelerationabs = std::move(_accelerationabs);
}

/*!
 * @brief This function returns a constant reference to member accelerationabs
 * @return Constant reference to member accelerationabs
 */
const Point3DFloat& ObjectInfo::accelerationabs() const
{
    return m_accelerationabs;
}

/*!
 * @brief This function returns a reference to member accelerationabs
 * @return Reference to member accelerationabs
 */
Point3DFloat& ObjectInfo::accelerationabs()
{
    return m_accelerationabs;
}
/*!
 * @brief This function copies the value in member timecreation
 * @param _timecreation New value to be copied in member timecreation
 */
void ObjectInfo::timecreation(
        const Time& _timecreation)
{
    m_timecreation = _timecreation;
}

/*!
 * @brief This function moves the value in member timecreation
 * @param _timecreation New value to be moved in member timecreation
 */
void ObjectInfo::timecreation(
        Time&& _timecreation)
{
    m_timecreation = std::move(_timecreation);
}

/*!
 * @brief This function returns a constant reference to member timecreation
 * @return Constant reference to member timecreation
 */
const Time& ObjectInfo::timecreation() const
{
    return m_timecreation;
}

/*!
 * @brief This function returns a reference to member timecreation
 * @return Reference to member timecreation
 */
Time& ObjectInfo::timecreation()
{
    return m_timecreation;
}
/*!
 * @brief This function copies the value in member lastupdatedtime
 * @param _lastupdatedtime New value to be copied in member lastupdatedtime
 */
void ObjectInfo::lastupdatedtime(
        const Time& _lastupdatedtime)
{
    m_lastupdatedtime = _lastupdatedtime;
}

/*!
 * @brief This function moves the value in member lastupdatedtime
 * @param _lastupdatedtime New value to be moved in member lastupdatedtime
 */
void ObjectInfo::lastupdatedtime(
        Time&& _lastupdatedtime)
{
    m_lastupdatedtime = std::move(_lastupdatedtime);
}

/*!
 * @brief This function returns a constant reference to member lastupdatedtime
 * @return Constant reference to member lastupdatedtime
 */
const Time& ObjectInfo::lastupdatedtime() const
{
    return m_lastupdatedtime;
}

/*!
 * @brief This function returns a reference to member lastupdatedtime
 * @return Reference to member lastupdatedtime
 */
Time& ObjectInfo::lastupdatedtime()
{
    return m_lastupdatedtime;
}
/*!
 * @brief This function copies the value in member sensorid
 * @param _sensorid New value to be copied in member sensorid
 */
void ObjectInfo::sensorid(
        const std::vector<uint32_t>& _sensorid)
{
    m_sensorid = _sensorid;
}

/*!
 * @brief This function moves the value in member sensorid
 * @param _sensorid New value to be moved in member sensorid
 */
void ObjectInfo::sensorid(
        std::vector<uint32_t>&& _sensorid)
{
    m_sensorid = std::move(_sensorid);
}

/*!
 * @brief This function returns a constant reference to member sensorid
 * @return Constant reference to member sensorid
 */
const std::vector<uint32_t>& ObjectInfo::sensorid() const
{
    return m_sensorid;
}

/*!
 * @brief This function returns a reference to member sensorid
 * @return Reference to member sensorid
 */
std::vector<uint32_t>& ObjectInfo::sensorid()
{
    return m_sensorid;
}
/*!
 * @brief This function sets a value in member motionpattern
 * @param _motionpattern New value for member motionpattern
 */
void ObjectInfo::motionpattern(
        uint32_t _motionpattern)
{
    m_motionpattern = _motionpattern;
}

/*!
 * @brief This function returns the value of member motionpattern
 * @return Value of member motionpattern
 */
uint32_t ObjectInfo::motionpattern() const
{
    return m_motionpattern;
}

/*!
 * @brief This function returns a reference to member motionpattern
 * @return Reference to member motionpattern
 */
uint32_t& ObjectInfo::motionpattern()
{
    return m_motionpattern;
}

/*!
 * @brief This function sets a value in member motionpatternhistory
 * @param _motionpatternhistory New value for member motionpatternhistory
 */
void ObjectInfo::motionpatternhistory(
        uint32_t _motionpatternhistory)
{
    m_motionpatternhistory = _motionpatternhistory;
}

/*!
 * @brief This function returns the value of member motionpatternhistory
 * @return Value of member motionpatternhistory
 */
uint32_t ObjectInfo::motionpatternhistory() const
{
    return m_motionpatternhistory;
}

/*!
 * @brief This function returns a reference to member motionpatternhistory
 * @return Reference to member motionpatternhistory
 */
uint32_t& ObjectInfo::motionpatternhistory()
{
    return m_motionpatternhistory;
}

/*!
 * @brief This function sets a value in member brakelightst
 * @param _brakelightst New value for member brakelightst
 */
void ObjectInfo::brakelightst(
        uint32_t _brakelightst)
{
    m_brakelightst = _brakelightst;
}

/*!
 * @brief This function returns the value of member brakelightst
 * @return Value of member brakelightst
 */
uint32_t ObjectInfo::brakelightst() const
{
    return m_brakelightst;
}

/*!
 * @brief This function returns a reference to member brakelightst
 * @return Reference to member brakelightst
 */
uint32_t& ObjectInfo::brakelightst()
{
    return m_brakelightst;
}

/*!
 * @brief This function sets a value in member turnlightst
 * @param _turnlightst New value for member turnlightst
 */
void ObjectInfo::turnlightst(
        uint32_t _turnlightst)
{
    m_turnlightst = _turnlightst;
}

/*!
 * @brief This function returns the value of member turnlightst
 * @return Value of member turnlightst
 */
uint32_t ObjectInfo::turnlightst() const
{
    return m_turnlightst;
}

/*!
 * @brief This function returns a reference to member turnlightst
 * @return Reference to member turnlightst
 */
uint32_t& ObjectInfo::turnlightst()
{
    return m_turnlightst;
}

/*!
 * @brief This function sets a value in member nearside
 * @param _nearside New value for member nearside
 */
void ObjectInfo::nearside(
        uint32_t _nearside)
{
    m_nearside = _nearside;
}

/*!
 * @brief This function returns the value of member nearside
 * @return Value of member nearside
 */
uint32_t ObjectInfo::nearside() const
{
    return m_nearside;
}

/*!
 * @brief This function returns a reference to member nearside
 * @return Reference to member nearside
 */
uint32_t& ObjectInfo::nearside()
{
    return m_nearside;
}

/*!
 * @brief This function copies the value in member associatedconf
 * @param _associatedconf New value to be copied in member associatedconf
 */
void ObjectInfo::associatedconf(
        const std::vector<float>& _associatedconf)
{
    m_associatedconf = _associatedconf;
}

/*!
 * @brief This function moves the value in member associatedconf
 * @param _associatedconf New value to be moved in member associatedconf
 */
void ObjectInfo::associatedconf(
        std::vector<float>&& _associatedconf)
{
    m_associatedconf = std::move(_associatedconf);
}

/*!
 * @brief This function returns a constant reference to member associatedconf
 * @return Constant reference to member associatedconf
 */
const std::vector<float>& ObjectInfo::associatedconf() const
{
    return m_associatedconf;
}

/*!
 * @brief This function returns a reference to member associatedconf
 * @return Reference to member associatedconf
 */
std::vector<float>& ObjectInfo::associatedconf()
{
    return m_associatedconf;
}
/*!
 * @brief This function sets a value in member age
 * @param _age New value for member age
 */
void ObjectInfo::age(
        uint32_t _age)
{
    m_age = _age;
}

/*!
 * @brief This function returns the value of member age
 * @return Value of member age
 */
uint32_t ObjectInfo::age() const
{
    return m_age;
}

/*!
 * @brief This function returns a reference to member age
 * @return Reference to member age
 */
uint32_t& ObjectInfo::age()
{
    return m_age;
}


size_t ObjectInfo::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;
























    return current_align;
}

bool ObjectInfo::isKeyDefined()
{
    return false;
}

void ObjectInfo::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
                         
}

ObjectVec::ObjectVec()
{
    // m_obj com.eprosima.idl.parser.typecode.SequenceTypeCode@548ad73b


    // Just to register all known types
    registerHelloWorldTypes();
}

ObjectVec::~ObjectVec()
{
}

ObjectVec::ObjectVec(
        const ObjectVec& x)
{
    m_obj = x.m_obj;
}

ObjectVec::ObjectVec(
        ObjectVec&& x) noexcept 
{
    m_obj = std::move(x.m_obj);
}

ObjectVec& ObjectVec::operator =(
        const ObjectVec& x)
{

    m_obj = x.m_obj;

    return *this;
}

ObjectVec& ObjectVec::operator =(
        ObjectVec&& x) noexcept
{

    m_obj = std::move(x.m_obj);

    return *this;
}

bool ObjectVec::operator ==(
        const ObjectVec& x) const
{

    return (m_obj == x.m_obj);
}

bool ObjectVec::operator !=(
        const ObjectVec& x) const
{
    return !(*this == x);
}

size_t ObjectVec::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += ObjectInfo::getMaxCdrSerializedSize(current_alignment);}

    return current_alignment - initial_alignment;
}

size_t ObjectVec::getCdrSerializedSize(
        const ObjectVec& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.obj().size(); ++a)
    {
        current_alignment += ObjectInfo::getCdrSerializedSize(data.obj().at(a), current_alignment);}

    return current_alignment - initial_alignment;
}

void ObjectVec::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_obj;
}

void ObjectVec::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_obj;}

/*!
 * @brief This function copies the value in member obj
 * @param _obj New value to be copied in member obj
 */
void ObjectVec::obj(
        const std::vector<ObjectInfo>& _obj)
{
    m_obj = _obj;
}

/*!
 * @brief This function moves the value in member obj
 * @param _obj New value to be moved in member obj
 */
void ObjectVec::obj(
        std::vector<ObjectInfo>&& _obj)
{
    m_obj = std::move(_obj);
}

/*!
 * @brief This function returns a constant reference to member obj
 * @return Constant reference to member obj
 */
const std::vector<ObjectInfo>& ObjectVec::obj() const
{
    return m_obj;
}

/*!
 * @brief This function returns a reference to member obj
 * @return Reference to member obj
 */
std::vector<ObjectInfo>& ObjectVec::obj()
{
    return m_obj;
}

size_t ObjectVec::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool ObjectVec::isKeyDefined()
{
    return false;
}

void ObjectVec::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
     
}
