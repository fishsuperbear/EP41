// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file TestWorld.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "TestWorld.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

TestWorld::TestWorld() {
    // m_cdrSerializedSize = 0;
}

TestWorld::~TestWorld() {}

TestWorld::TestWorld(const TestWorld& x) {
    // m_index = x.m_index;
    // m_message = x.m_message;
    // m_cdrSerializedSize = x.m_cdrSerializedSize;
}

TestWorld::TestWorld(TestWorld&& x) {
    // m_index = x.m_index;
    // m_message = std::move(x.m_message);
    // m_cdrSerializedSize = x.m_cdrSerializedSize;
}

TestWorld& TestWorld::operator=(const TestWorld& x) {

    // m_index = x.m_index;
    // m_message = x.m_message;
    // m_cdrSerializedSize = x.m_cdrSerializedSize;
    return *this;
}

TestWorld& TestWorld::operator=(TestWorld&& x) {

    // m_index = x.m_index;
    // m_message = std::move(x.m_message);
    // m_cdrSerializedSize = x.m_cdrSerializedSize;

    return *this;
}

bool TestWorld::operator==(const TestWorld& x) const {

    // return (m_index == x.m_index && m_message == x.m_message);
    // return (m_cdrSerializedSize == x.m_cdrSerializedSize);
    return true;
}

bool TestWorld::operator!=(const TestWorld& x) const {
    return !(*this == x);
}

size_t TestWorld::getMaxCdrSerializedSize(size_t current_alignment) {
    // size_t initial_alignment = current_alignment;

    // current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    // return current_alignment - initial_alignment;
    return 88;
}

size_t TestWorld::getCdrSerializedSize(const TestWorld& data, size_t current_alignment) {
    return data.m_payload.length;
    // (void)data;
    // size_t initial_alignment = current_alignment;

    // current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.message().size() + 1;

    // return current_alignment - initial_alignment;
}

// void TestWorld::serialize(
//         eprosima::fastcdr::Cdr& scdr) const
// {

//     // scdr << m_index;
//     // scdr << m_message.c_str();
//     std::cout << "Error: TestWorld::serialize is called!" << std::endl;
// }

void TestWorld::deserialize(eprosima::fastcdr::Cdr& dcdr) {

    // dcdr >> m_index;
    // dcdr >> m_message;
    std::cout << "Error: TestWorld::deserialize is called!" << std::endl;
}

// void TestWorld::cdrSerializedSize(size_t size)
// {
//     m_cdrSerializedSize = size;
// }

size_t TestWorld::getKeyMaxCdrSerializedSize(size_t current_alignment) {
    // size_t current_align = current_alignment;
    // return current_align;
    std::cout << "Error: TestWorld::getKeyMaxCdrSerializedSize is called!" << std::endl;
    return 0;
}

bool TestWorld::isKeyDefined() {
    return false;
}

void TestWorld::serializeKey(eprosima::fastcdr::Cdr& scdr) const {
    (void)scdr;
}
