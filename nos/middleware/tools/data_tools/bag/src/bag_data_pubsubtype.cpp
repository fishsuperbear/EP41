// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file HelloWorldPubSubTypes.cpp
 * This header file contains the implementation of the serialization functions.
 *
 * This file was generated by the tool fastddsgen.
 */

#include <fastcdr/Cdr.h>
#include <fastcdr/CdrSizeCalculator.hpp>
#include <fastcdr/FastBuffer.h>

// #include "HelloWorldCdrAux.hpp"
// #include "HelloWorldPubSubTypes.h"
#include "bag_data_pubsubtype.h"

using SerializedPayload_t = eprosima::fastrtps::rtps::SerializedPayload_t;
using InstanceHandle_t = eprosima::fastrtps::rtps::InstanceHandle_t;
using DataRepresentationId_t = eprosima::fastdds::dds::DataRepresentationId_t;

HelloWorldPubSubType::HelloWorldPubSubType() {
    setName("HelloWorld");
    // uint32_t type_size = HelloWorld_max_cdr_typesize;
    uint64_t type_size = 225;
    type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
    m_typeSize = type_size + 4;                                                          /*encapsulation*/
    // m_isGetKeyDefined = false;
    // uint32_t keyLength = HelloWorld_max_key_cdr_typesize > 16 ? HelloWorld_max_key_cdr_typesize : 16;
    // m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
    // memset(m_keyBuffer, 0, keyLength);
}

HelloWorldPubSubType::~HelloWorldPubSubType() {
    // if (m_keyBuffer != nullptr) {
    //     free(m_keyBuffer);
    // }
}

bool HelloWorldPubSubType::serialize(void* data, SerializedPayload_t* payload, DataRepresentationId_t data_representation) {
    BagDataType* p_type = static_cast<BagDataType*>(data);
    payload->copy(p_type->m_payload.get(), false);

    // // Object that manages the raw buffer.
    // eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
    // // Object that serializes the data.
    // eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
    //                            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ? eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
    // payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // ser.set_encoding_flag(data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ? eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR
    //                                                                                               : eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);

    // try {
    //     // Serialize encapsulation
    //     ser.serialize_encapsulation();
    //     // Serialize the object.
    //     ser << *p_type;
    // } catch (eprosima::fastcdr::exception::Exception& /*exception*/) {
    //     return false;
    // }

    // // Get the serialized length
    // payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    return true;
}

//采用C模式写二进制文件
// void DataWrite_CMode(SerializedPayload_t* payload) {
//     std::cout << "开始记录序列化数据:" << std::endl;
//     //准备数据
//     // double pos[200];
//     // for(int i = 0; i < 200; i ++ )
//     //     pos[i] = i ;
//     //写出数据DataWrite_CMode
//     std::cout << "DataWrite_CMode start" << std::endl;
//     FILE* fid;
//     fid = fopen("binary.dat", "ab");
//     if (fid == NULL) {
//         printf("写出文件出错");
//         return;
//     }
//     fwrite(&(payload->encapsulation), sizeof(uint16_t), 1, fid);
//     fwrite(&(payload->length), sizeof(uint32_t), 1, fid);
//     fwrite(payload->data, sizeof(unsigned char), payload->length, fid);
//     fwrite(&(payload->max_size), sizeof(uint32_t), 1, fid);
//     fwrite(&(payload->pos), sizeof(uint32_t), 1, fid);
//     fclose(fid);
// }

bool HelloWorldPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
    // try {
    // Convert DATA to pointer of your type
    BagDataType* p_type = static_cast<BagDataType*>(data);
    p_type->m_payload->copy(payload, false);

    //     // Object that manages the raw buffer.
    //     eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

    //     // Object that deserializes the data.
    //     eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);

    //     // Deserialize encapsulation.
    //     deser.read_encapsulation();
    //     payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    //     // Deserialize the object.
    //     deser >> *p_type;
    // } catch (eprosima::fastcdr::exception::Exception& /*exception*/) {
    //     return false;
    // } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {
    //     return false;
    // }

    return true;
}

std::function<uint32_t()> HelloWorldPubSubType::getSerializedSizeProvider(void* data, DataRepresentationId_t data_representation) {
    return [data, data_representation]() -> uint32_t {
        // std::cout << "\033[1;31m"
        //           << "this getSerializedSizeProvider() can't be called!"
        //           << "\033[0m";  // 恢复默认颜色
        // eprosima::fastcdr::CdrSizeCalculator calculator(data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ? eprosima::fastcdr::CdrVersion::XCDRv1
        //                                                                                                                         : eprosima::fastcdr::CdrVersion::XCDRv2);
        // size_t current_alignment{0};
        // return static_cast<uint32_t>(calculator.calculate_serialized_size(*static_cast<BagDataType*>(data), current_alignment)) + 4u /*encapsulation*/;
        return static_cast<BagDataType*>(data)->m_payload->length + 4u;
    };
}

void* HelloWorldPubSubType::createData() {
    return reinterpret_cast<void*>(new BagDataType());
}

void HelloWorldPubSubType::deleteData(void* data) {
    delete (reinterpret_cast<BagDataType*>(data));
}

bool HelloWorldPubSubType::getKey(void* data, InstanceHandle_t* handle, bool force_md5) {
    std::cout << "\033[1;31m"
              << "this getKey() can't be called!"
              << "\033[0m";  // 恢复默认颜色
    // if (!m_isGetKeyDefined) {
    //     return false;
    // }

    // BagDataType* p_type = static_cast<BagDataType*>(data);

    // // Object that manages the raw buffer.
    // eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer), HelloWorld_max_key_cdr_typesize);

    // // Object that serializes the data.
    // eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);
    // eprosima::fastcdr::serialize_key(ser, *p_type);
    // if (force_md5 || HelloWorld_max_key_cdr_typesize > 16) {
    //     m_md5.init();
    //     m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    //     m_md5.finalize();
    //     for (uint8_t i = 0; i < 16; ++i) {
    //         handle->value[i] = m_md5.digest[i];
    //     }
    // } else {
    //     for (uint8_t i = 0; i < 16; ++i) {
    //         handle->value[i] = m_keyBuffer[i];
    //     }
    // }
    return true;
}
