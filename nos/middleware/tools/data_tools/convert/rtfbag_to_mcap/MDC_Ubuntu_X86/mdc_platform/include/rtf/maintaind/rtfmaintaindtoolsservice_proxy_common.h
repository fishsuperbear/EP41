/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2020-2020. All rights reserved.
 * Generated by VRTF CM-Generator
 */

#ifndef RTF_MAINTAIND_RTFMAINTAINDTOOLSSERVICE_PROXY_COMMON_H
#define RTF_MAINTAIND_RTFMAINTAINDTOOLSSERVICE_PROXY_COMMON_H

#include "ara/com/internal/proxy/proxy_adapter.h"
#include "ara/com/internal/proxy/event_adapter.h"
#include "ara/com/internal/proxy/field_adapter.h"
#include "ara/com/internal/proxy/method_adapter.h"
#include "rtf/maintaind/rtfmaintaindtoolsservice_common.h"
#include <string>

namespace rtf {
namespace maintaind {
namespace proxy {
namespace methods {
static constexpr ara::com::internal::EntityId QueryAllDataTypeId = 56963U; // QueryAllDataType_method_hash
static constexpr ara::com::internal::EntityId QueryDataTypeId = 32777U; // QueryDataType_method_hash
static constexpr ara::com::internal::EntityId QueryDataTypeRefListId = 60394U; // QueryDataTypeRefList_method_hash
static constexpr ara::com::internal::EntityId QueryEventInfoId = 40538U; // QueryEventInfo_method_hash
static constexpr ara::com::internal::EntityId QueryEventShowId = 23108U; // QueryEventShow_method_hash
static constexpr ara::com::internal::EntityId QueryLatencyResultId = 58300U; // QueryLatencyResult_method_hash
static constexpr ara::com::internal::EntityId QueryLatencyStatusId = 3562U; // QueryLatencyStatus_method_hash
static constexpr ara::com::internal::EntityId QueryMethodInfoId = 38078U; // QueryMethodInfo_method_hash
static constexpr ara::com::internal::EntityId QueryMethodTypeId = 12452U; // QueryMethodType_method_hash
static constexpr ara::com::internal::EntityId QueryNodeInfoId = 47109U; // QueryNodeInfo_method_hash
static constexpr ara::com::internal::EntityId QuerySubNodeEventInfoId = 7391U; // QuerySubNodeEventInfo_method_hash
static constexpr ara::com::internal::EntityId SwitchLatencyModeId = 63267U; // SwitchLatencyMode_method_hash

class QueryAllDataType {
public:
    struct Output {
        ::rtf::maintaind::DataTypeMap dataTypeList;

        static bool IsPlane() noexcept
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun) noexcept
        {
            fun(dataTypeList);
        }

        template<typename F>
        void enumerate(F& fun) const noexcept
        {
            fun(dataTypeList);
        }

        bool operator == (const Output& t) const noexcept
        {
            return (dataTypeList == t.dataTypeList);
        }
    };

    QueryAllDataType(std::shared_ptr<vrtf::vcc::Proxy>& proxy, ara::com::internal::EntityId entityId)
        : method_(proxy, entityId){}
    ~QueryAllDataType() = default;
    void Initialize(std::shared_ptr<vrtf::vcc::Proxy>& proxy, ara::com::internal::EntityId entityId)
    {
        method_.Initialize(proxy, entityId);
    }
    ara::core::Future<Output> operator()()
    {
        return method_();
    }

private:
    ara::com::internal::proxy::method::MethodAdapter<Output> method_;
};

class QueryDataType {
public:
    struct Output {
        ::rtf::stdtype::String type;

        static bool IsPlane() noexcept
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun) noexcept
        {
            fun(type);
        }

        template<typename F>
        void enumerate(F& fun) const noexcept
        {
            fun(type);
        }

        bool operator == (const Output& t) const noexcept
        {
            return (type == t.type);
        }
    };

    QueryDataType(std::shared_ptr<vrtf::vcc::Proxy>& proxy, ara::com::internal::EntityId entityId)
        : method_(proxy, entityId){}
    ~QueryDataType() = default;
    void Initialize(std::shared_ptr<vrtf::vcc::Proxy>& proxy, ara::com::internal::EntityId entityId)
    {
        method_.Initialize(proxy, entityId);
    }
    ara::core::Future<Output> operator()(const ::rtf::stdtype::String& msgName)
    {
        return method_(msgName);
    }

private:
    ara::com::internal::proxy::method::MethodAdapter<Output, ::rtf::stdtype::String> method_;
};

class QueryDataTypeRefList {
public:
    struct Output {
        ::rtf::maintaind::DataTypeRefMap dataTypeRefList;

        static bool IsPlane() noexcept
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun) noexcept
        {
            fun(dataTypeRefList);
        }

        template<typename F>
        void enumerate(F& fun) const noexcept
        {
            fun(dataTypeRefList);
        }

        bool operator == (const Output& t) const noexcept
        {
            return (dataTypeRefList == t.dataTypeRefList);
        }
    };

    QueryDataTypeRefList(std::shared_ptr<vrtf::vcc::Proxy>& proxy, ara::com::internal::EntityId entityId)
        : method_(proxy, entityId){}
    ~QueryDataTypeRefList() = default;
    void Initialize(std::shared_ptr<vrtf::vcc::Proxy>& proxy, ara::com::internal::EntityId entityId)
    {
        method_.Initialize(proxy, entityId);
    }
    ara::core::Future<Output> operator()()
    {
        return method_();
    }

private:
    ara::com::internal::proxy::method::MethodAdapter<Output> method_;
};

class QueryEventInfo {
public:
    struct Output {
        ::rtf::maintaind::QueryEventInfoReturnType eventInfo;

        static bool IsPlane() noexcept
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun) noexcept
        {
            fun(eventInfo);
        }

        template<typename F>
        void enumerate(F& fun) const noexcept
        {
            fun(eventInfo);
        }

        bool operator == (const Output& t) const noexcept
        {
            return (eventInfo == t.eventInfo);
        }
    };

    QueryEventInfo(std::shared_ptr<vrtf::vcc::Proxy>& proxy, ara::com::internal::EntityId entityId)
        : method_(proxy, entityId){}
    ~QueryEventInfo() = default;
    void Initialize(std::shared_ptr<vrtf::vcc::Proxy>& proxy, ara::com::internal::EntityId entityId)
    {
        method_.Initialize(proxy, entityId);
    }
    ara::core::Future<Output> operator()(const ::rtf::stdtype::String& eventName)
    {
        return method_(eventName);
    }

private:
    ara::com::internal::proxy::method::MethodAdapter<Output, ::rtf::stdtype::String> method_;
};

class QueryEventShow {
public:
    struct Output {
        ::rtf::stdtype::String type;
        ::rtf::stdtype::String pub;
        ::rtf::stdtype::String pubStatus;

        static bool IsPlane() noexcept
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun) noexcept
        {
            fun(type);
            fun(pub);
            fun(pubStatus);
        }

        template<typename F>
        void enumerate(F& fun) const noexcept
        {
            fun(type);
            fun(pub);
            fun(pubStatus);
        }

        bool operator == (const Output& t) const noexcept
        {
            return (type == t.type) && (pub == t.pub) && (pubStatus == t.pubStatus);
        }
    };

    QueryEventShow(std::shared_ptr<vrtf::vcc::Proxy>& proxy, ara::com::internal::EntityId entityId)
        : method_(proxy, entityId){}
    ~QueryEventShow() = default;
    void Initialize(std::shared_ptr<vrtf::vcc::Proxy>& proxy, ara::com::internal::EntityId entityId)
    {
        method_.Initialize(proxy, entityId);
    }
    ara::core::Future<Output> operator()(const ::rtf::stdtype::String& eventName)
    {
        return method_(eventName);
    }

private:
    ara::com::internal::proxy::method::MethodAdapter<Output, ::rtf::stdtype::String> method_;
};

class QueryLatencyResult {
public:
    struct Output {
        ::rtf::maintaind::LatencyResultMap latencyResultMap;

        static bool IsPlane() noexcept
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun) noexcept
        {
            fun(latencyResultMap);
        }

        template<typename F>
        void enumerate(F& fun) const noexcept
        {
            fun(latencyResultMap);
        }

        bool operator == (const Output& t) const noexcept
        {
            return (latencyResultMap == t.latencyResultMap);
        }
    };

    QueryLatencyResult(std::shared_ptr<vrtf::vcc::Proxy>& proxy, ara::com::internal::EntityId entityId)
        : method_(proxy, entityId){}
    ~QueryLatencyResult() = default;
    void Initialize(std::shared_ptr<vrtf::vcc::Proxy>& proxy, ara::com::internal::EntityId entityId)
    {
        method_.Initialize(proxy, entityId);
    }
    ara::core::Future<Output> operator()(const ::rtf::maintaind::LatencyQueryInfo& latencyQueryInfo)
    {
        return method_(latencyQueryInfo);
    }

private:
    ara::com::internal::proxy::method::MethodAdapter<Output, ::rtf::maintaind::LatencyQueryInfo> method_;
};

class QueryLatencyStatus {
public:
    struct Output {
        ::rtf::maintaind::LatencyStatus latencyStatus;

        static bool IsPlane() noexcept
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun) noexcept
        {
            fun(latencyStatus);
        }

        template<typename F>
        void enumerate(F& fun) const noexcept
        {
            fun(latencyStatus);
        }

        bool operator == (const Output& t) const noexcept
        {
            return (latencyStatus == t.latencyStatus);
        }
    };

    QueryLatencyStatus(std::shared_ptr<vrtf::vcc::Proxy>& proxy, ara::com::internal::EntityId entityId)
        : method_(proxy, entityId){}
    ~QueryLatencyStatus()  = default;
    void Initialize(std::shared_ptr<vrtf::vcc::Proxy>& proxy, ara::com::internal::EntityId entityId)
    {
        method_.Initialize(proxy, entityId);
    }
    ara::core::Future<Output> operator()(const ::rtf::maintaind::LatencyIndex& latencyIndex)
    {
        return method_(latencyIndex);
    }

private:
    ara::com::internal::proxy::method::MethodAdapter<Output, ::rtf::maintaind::LatencyIndex> method_;
};

class QueryMethodInfo {
public:
    struct Output {
        ::rtf::maintaind::QueryMethodInfoReturnType methodInfo;

        static bool IsPlane() noexcept
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun) noexcept
        {
            fun(methodInfo);
        }

        template<typename F>
        void enumerate(F& fun) const noexcept
        {
            fun(methodInfo);
        }

        bool operator == (const Output& t) const noexcept
        {
            return (methodInfo == t.methodInfo);
        }
    };

    QueryMethodInfo(std::shared_ptr<vrtf::vcc::Proxy>& proxy, ara::com::internal::EntityId entityId)
        : method_(proxy, entityId){}
    ~QueryMethodInfo() = default;
    void Initialize(std::shared_ptr<vrtf::vcc::Proxy>& proxy, ara::com::internal::EntityId entityId)
    {
        method_.Initialize(proxy, entityId);
    }
    ara::core::Future<Output> operator()(const ::rtf::stdtype::String& methodName)
    {
        return method_(methodName);
    }

private:
    ara::com::internal::proxy::method::MethodAdapter<Output, ::rtf::stdtype::String> method_;
};

class QueryMethodType {
public:
    struct Output {
        ::rtf::maintaind::MethodDatatypeInfo methodDatatypeInfo;

        static bool IsPlane() noexcept
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun) noexcept
        {
            fun(methodDatatypeInfo);
        }

        template<typename F>
        void enumerate(F& fun) const noexcept
        {
            fun(methodDatatypeInfo);
        }

        bool operator == (const Output& t) const noexcept
        {
            return (methodDatatypeInfo == t.methodDatatypeInfo);
        }
    };

    QueryMethodType(std::shared_ptr<vrtf::vcc::Proxy>& proxy, ara::com::internal::EntityId entityId)
        : method_(proxy, entityId){}
    ~QueryMethodType() = default;
    void Initialize(std::shared_ptr<vrtf::vcc::Proxy>& proxy, ara::com::internal::EntityId entityId)
    {
        method_.Initialize(proxy, entityId);
    }
    ara::core::Future<Output> operator()(const ::rtf::stdtype::String& methodName)
    {
        return method_(methodName);
    }

private:
    ara::com::internal::proxy::method::MethodAdapter<Output, ::rtf::stdtype::String> method_;
};

class QueryNodeInfo {
public:
    struct Output {
        ::rtf::maintaind::VectorNodeInfo nodeInfoList;

        static bool IsPlane() noexcept
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun) noexcept
        {
            fun(nodeInfoList);
        }

        template<typename F>
        void enumerate(F& fun) const noexcept
        {
            fun(nodeInfoList);
        }

        bool operator == (const Output& t) const noexcept
        {
            return (nodeInfoList == t.nodeInfoList);
        }
    };

    QueryNodeInfo(std::shared_ptr<vrtf::vcc::Proxy>& proxy, ara::com::internal::EntityId entityId)
        : method_(proxy, entityId){}
    ~QueryNodeInfo() = default;
    void Initialize(std::shared_ptr<vrtf::vcc::Proxy>& proxy, ara::com::internal::EntityId entityId)
    {
        method_.Initialize(proxy, entityId);
    }
    ara::core::Future<Output> operator()(const ::rtf::stdtype::String& appName)
    {
        return method_(appName);
    }

private:
    ara::com::internal::proxy::method::MethodAdapter<Output, ::rtf::stdtype::String> method_;
};

class QuerySubNodeEventInfo {
public:
    struct Output {
        ::rtf::maintaind::EventInfoWithPubSub eventInfoWithSub;

        static bool IsPlane() noexcept
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun) noexcept
        {
            fun(eventInfoWithSub);
        }

        template<typename F>
        void enumerate(F& fun) const noexcept
        {
            fun(eventInfoWithSub);
        }

        bool operator == (const Output& t) const noexcept
        {
            return (eventInfoWithSub == t.eventInfoWithSub);
        }
    };

    QuerySubNodeEventInfo(std::shared_ptr<vrtf::vcc::Proxy>& proxy, ara::com::internal::EntityId entityId)
        : method_(proxy, entityId){}
    ~QuerySubNodeEventInfo() = default;
    void Initialize(std::shared_ptr<vrtf::vcc::Proxy>& proxy, ara::com::internal::EntityId entityId)
    {
        method_.Initialize(proxy, entityId);
    }
    ara::core::Future<Output> operator()(const ::rtf::maintaind::QuerySubEventInfoIndex& querySubEventInfoIndex)
    {
        return method_(querySubEventInfoIndex);
    }

private:
    ara::com::internal::proxy::method::MethodAdapter<Output, ::rtf::maintaind::QuerySubEventInfoIndex> method_;
};

class SwitchLatencyMode {
public:
    struct Output {
        ::rtf::maintaind::ReturnCode result;

        static bool IsPlane() noexcept
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun) noexcept
        {
            fun(result);
        }

        bool operator == (const Output& t) const noexcept
        {
            return (result == t.result);
        }
    };

    SwitchLatencyMode(std::shared_ptr<vrtf::vcc::Proxy>& proxy, ara::com::internal::EntityId entityId)
        : method_(proxy, entityId){}
    ~SwitchLatencyMode() = default;
    void Initialize(std::shared_ptr<vrtf::vcc::Proxy>& proxy, ara::com::internal::EntityId entityId)
    {
        method_.Initialize(proxy, entityId);
    }
    ara::core::Future<Output> operator()(const ::rtf::maintaind::LatencySwitch& latencySwitch)
    {
        return method_(latencySwitch);
    }

private:
    ara::com::internal::proxy::method::MethodAdapter<Output, ::rtf::maintaind::LatencySwitch> method_;
};
} // namespace methods
} // namespace proxy
} // namespace maintaind
} // namespace rtf

#endif // RTF_MAINTAIND_RTFMAINTAINDTOOLSSERVICE_PROXY_H
