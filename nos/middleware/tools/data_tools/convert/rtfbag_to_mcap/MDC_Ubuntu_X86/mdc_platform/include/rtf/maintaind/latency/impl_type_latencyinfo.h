/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2020-2021. All rights reserved.
 * Generated by VRTF CM-Generator
 */

#ifndef RTF_MAINTAIND_IMPL_TYPE_LATENCYINFO_H
#define RTF_MAINTAIND_IMPL_TYPE_LATENCYINFO_H
#include "rtf/maintaind/latency/impl_type_requestmode.h"
#include "rtf/stdtype/impl_type_string.h"
#include "rtf/maintaind/latency/impl_type_latencyindex.h"
#include "rtf/maintaind/latency/impl_type_latencymodeackinfo.h"
#include "rtf/maintaind/latency/impl_type_latencyresultinfo.h"
namespace rtf {
namespace maintaind {
struct LatencyInfo {
    RequestMode latencyRequestMode_; // use to distinguish ack method and preriodic report method
    ::rtf::stdtype::String applicationName_;
    ::rtf::maintaind::LatencyIndex latencyIndex_;
    ::rtf::maintaind::LatencyModeAckInfo ackInfo_;
    LatencyResultInfo latencyResultInfo_;
    static bool IsPlane() noexcept
    {
        return false;
    }

    using IsEnumerableTag = void;
    template<typename F>
    void enumerate(F& fun) noexcept
    {
        fun(latencyRequestMode_);
        fun(applicationName_);
        fun(latencyIndex_);
        fun(ackInfo_);
        fun(latencyResultInfo_);
    }

    template<typename F>
    void enumerate(F& fun) const noexcept
    {
        fun(latencyRequestMode_);
        fun(applicationName_);
        fun(latencyIndex_);
        fun(ackInfo_);
        fun(latencyResultInfo_);
    }

    bool operator == (const ::rtf::maintaind::LatencyInfo& t) const noexcept
    {
        return (latencyRequestMode_ == t.latencyRequestMode_) && (applicationName_ == t.applicationName_) &&
            (latencyIndex_ == t.latencyIndex_) && (ackInfo_ == t.ackInfo_) &&
            (latencyResultInfo_ == t.latencyResultInfo_);
    }
};
} // namespace maintaind
} // namespace rtf


#endif // RTF_MAINTAIND_IMPL_TYPE_LATENCYINFO_H
