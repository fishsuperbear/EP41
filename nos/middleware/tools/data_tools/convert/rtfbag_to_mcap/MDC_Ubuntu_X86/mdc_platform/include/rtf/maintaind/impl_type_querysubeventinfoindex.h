/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2020-2020. All rights reserved.
 * Generated by VRTF CM-Generator
 */

#ifndef RTF_MAINTAIND_IMPL_TYPE_QUERYSUBEVENTINFOINDEX_H
#define RTF_MAINTAIND_IMPL_TYPE_QUERYSUBEVENTINFOINDEX_H
#include "rtf/stdtype/impl_type_uint16_t.h"
#include "rtf/maintaind/impl_type_drivertype.h"
#include "rtf/stdtype/impl_type_string.h"
#include "rtf/maintaind/impl_type_querysubinfotype.h"

namespace rtf {
namespace maintaind {
struct QuerySubEventInfoIndex {
    ::rtf::stdtype::uint16_t serviceId_;
    ::rtf::stdtype::uint16_t instanceId_;
    ::rtf::maintaind::DriverType driverType_;
    ::rtf::stdtype::uint16_t eventId_;
    ::rtf::stdtype::String eventTopicName_;
    ::rtf::stdtype::String pubEventType_;
    ::rtf::maintaind::QuerySubInfoType querySubInfoType_;
    static bool IsPlane() noexcept
    {
        return false;
    }

    using IsEnumerableTag = void;
    template<typename F>
    void enumerate(F& fun) noexcept
    {
        fun(serviceId_);
        fun(instanceId_);
        fun(driverType_);
        fun(eventId_);
        fun(eventTopicName_);
        fun(pubEventType_);
        fun(querySubInfoType_);
    }

    template<typename F>
    void enumerate(F& fun) const noexcept
    {
        fun(serviceId_);
        fun(instanceId_);
        fun(driverType_);
        fun(eventId_);
        fun(eventTopicName_);
        fun(pubEventType_);
        fun(querySubInfoType_);
    }

    bool operator == (const ::rtf::maintaind::QuerySubEventInfoIndex& t) const noexcept
    {
        return (serviceId_ == t.serviceId_) && (instanceId_ == t.instanceId_) && (driverType_ == t.driverType_) &&
        (eventId_ == t.eventId_) && (eventTopicName_ == t.eventTopicName_) && (pubEventType_ == t.pubEventType_) &&
        (querySubInfoType_ == t.querySubInfoType_);
    }
};
} // namespace maintaind
} // namespace rtf


#endif // RTF_MAINTAIND_IMPL_TYPE_QUERYSUBEVENTINFOINDEX_H
