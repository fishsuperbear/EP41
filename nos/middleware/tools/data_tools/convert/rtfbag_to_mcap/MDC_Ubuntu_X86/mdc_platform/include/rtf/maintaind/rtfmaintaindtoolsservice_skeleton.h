/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2020-2020. All rights reserved.
 * Generated by VRTF CM-Generator
 */

#ifndef RTF_MAINTAIND_RTFMAINTAINDTOOLSSERVICE_SKELETON_H
#define RTF_MAINTAIND_RTFMAINTAINDTOOLSSERVICE_SKELETON_H

#include "ara/com/internal/skeleton/skeleton_adapter.h"
#include "ara/com/internal/skeleton/event_adapter.h"
#include "ara/com/internal/skeleton/field_adapter.h"
#include "ara/com/internal/skeleton/method_adapter.h"
#include "rtf/maintaind/rtfmaintaindtoolsservice_common.h"
#include "rtf/maintaind/rtfmaintaindtoolsservice_skeleton_common.h"
#include <cstdint>
#include <cfloat>
#include <cmath>

namespace rtf {
namespace maintaind {
namespace skeleton {
class RTFMaintaindToolsServiceSkeleton {
private:
    std::unique_ptr<ara::com::internal::skeleton::SkeletonAdapter> skeletonAdapter;
    void ConstructSkeleton(ara::com::MethodCallProcessingMode mode)
    {
        bool result = true;
        if (mode == ara::com::MethodCallProcessingMode::kEvent) {
            // 12 mean thread number to trigger method callback
            std::uint16_t threadNum = 12U;
            std::uint16_t taskNum = 1024U;
            result = result && skeletonAdapter->SetMethodThreadNumber(
                skeletonAdapter->GetMethodThreadNumber(threadNum), taskNum);
        }
        result = result && ((skeletonAdapter->InitializeMethod<ara::core::Future<QueryAllDataTypeOutput>>(
            methods::QueryAllDataTypeId)).HasValue());
        result = result && ((skeletonAdapter->InitializeMethod<ara::core::Future<QueryDataTypeOutput>>(
            methods::QueryDataTypeId)).HasValue());
        result = result && ((skeletonAdapter->InitializeMethod<ara::core::Future<QueryDataTypeRefListOutput>>(
            methods::QueryDataTypeRefListId)).HasValue());
        result = result && ((skeletonAdapter->InitializeMethod<ara::core::Future<QueryEventInfoOutput>>(
            methods::QueryEventInfoId)).HasValue());
        result = result && ((skeletonAdapter->InitializeMethod<ara::core::Future<QueryEventShowOutput>>(
            methods::QueryEventShowId)).HasValue());
        result = result && ((skeletonAdapter->InitializeMethod<ara::core::Future<QueryLatencyResultOutput>>(
            methods::QueryLatencyResultId)).HasValue());
        result = result && ((skeletonAdapter->InitializeMethod<ara::core::Future<QueryLatencyStatusOutput>>(
            methods::QueryLatencyStatusId)).HasValue());
        result = result && ((skeletonAdapter->InitializeMethod<ara::core::Future<QueryMethodInfoOutput>>(
            methods::QueryMethodInfoId)).HasValue());
        result = result && ((skeletonAdapter->InitializeMethod<ara::core::Future<QueryMethodTypeOutput>>(
            methods::QueryMethodTypeId)).HasValue());
        result = result && ((skeletonAdapter->InitializeMethod<ara::core::Future<QueryNodeInfoOutput>>(
            methods::QueryNodeInfoId)).HasValue());
        result = result && ((skeletonAdapter->InitializeMethod<ara::core::Future<QuerySubNodeEventInfoOutput>>(
            methods::QuerySubNodeEventInfoId)).HasValue());
        result = result && ((skeletonAdapter->InitializeMethod<ara::core::Future<SwitchLatencyModeOutput>>(
            methods::SwitchLatencyModeId)).HasValue());
        if (result == false) {
#ifndef NOT_SUPPORT_EXCEPTIONS
            ara::core::ErrorCode errorcode(ara::com::ComErrc::kNetworkBindingFailure);
            throw ara::com::ComException(std::move(errorcode));
#else
            std::cerr << "Error: Not support exception, create skeleton failed!"<< std::endl;
#endif
        }
    }
public:
    struct QueryAllDataTypeOutput {
        ::rtf::maintaind::DataTypeMap dataTypeList;

        static bool IsPlane() noexcept
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun) noexcept
        {
            fun(dataTypeList);
        }

        template<typename F>
        void enumerate(F& fun) const noexcept
        {
            fun(dataTypeList);
        }

        bool operator == (const QueryAllDataTypeOutput& t) const noexcept
        {
            return (dataTypeList == t.dataTypeList);
        }
    };

    struct QueryDataTypeOutput {
        ::rtf::stdtype::String type;

        static bool IsPlane() noexcept
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun) noexcept
        {
            fun(type);
        }

        template<typename F>
        void enumerate(F& fun) const noexcept
        {
            fun(type);
        }

        bool operator == (const QueryDataTypeOutput& t) const noexcept
        {
            return (type == t.type);
        }
    };

    struct QueryDataTypeRefListOutput {
        ::rtf::maintaind::DataTypeRefMap dataTypeRefList;

        static bool IsPlane() noexcept
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun) noexcept
        {
            fun(dataTypeRefList);
        }

        template<typename F>
        void enumerate(F& fun) const noexcept
        {
            fun(dataTypeRefList);
        }

        bool operator == (const QueryDataTypeRefListOutput& t) const noexcept
        {
            return (dataTypeRefList == t.dataTypeRefList);
        }
    };

    struct QueryEventInfoOutput {
        ::rtf::maintaind::QueryEventInfoReturnType eventInfo;

        static bool IsPlane() noexcept
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun) noexcept
        {
            fun(eventInfo);
        }

        template<typename F>
        void enumerate(F& fun) const noexcept
        {
            fun(eventInfo);
        }

        bool operator == (const QueryEventInfoOutput& t) const noexcept
        {
            return (eventInfo == t.eventInfo);
        }
    };

    struct QueryEventShowOutput {
        ::rtf::stdtype::String type;
        ::rtf::stdtype::String pub;
        ::rtf::stdtype::String pubStatus;

        static bool IsPlane() noexcept
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun) noexcept
        {
            fun(type);
            fun(pub);
            fun(pubStatus);
        }

        template<typename F>
        void enumerate(F& fun) const noexcept
        {
            fun(type);
            fun(pub);
            fun(pubStatus);
        }

        bool operator == (const QueryEventShowOutput& t) const noexcept
        {
            return (type == t.type) && (pub == t.pub) && (pubStatus == t.pubStatus);
        }
    };

    struct QueryLatencyResultOutput {
        ::rtf::maintaind::LatencyResultMap latencyResultMap;

        static bool IsPlane() noexcept
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun) noexcept
        {
            fun(latencyResultMap);
        }

        template<typename F>
        void enumerate(F& fun) const noexcept
        {
            fun(latencyResultMap);
        }

        bool operator == (const QueryLatencyResultOutput& t) const noexcept
        {
            return (latencyResultMap == t.latencyResultMap);
        }
    };

    struct QueryLatencyStatusOutput {
        ::rtf::maintaind::LatencyStatus latencyStatus;

        static bool IsPlane() noexcept
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun) noexcept
        {
            fun(latencyStatus);
        }

        template<typename F>
        void enumerate(F& fun) const noexcept
        {
            fun(latencyStatus);
        }

        bool operator == (const QueryLatencyStatusOutput& t) const noexcept
        {
            return (latencyStatus == t.latencyStatus);
        }
    };

    struct QueryMethodInfoOutput {
        ::rtf::maintaind::QueryMethodInfoReturnType methodInfo;

        static bool IsPlane() noexcept
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun) noexcept
        {
            fun(methodInfo);
        }

        template<typename F>
        void enumerate(F& fun) const noexcept
        {
            fun(methodInfo);
        }

        bool operator == (const QueryMethodInfoOutput& t) const noexcept
        {
            return (methodInfo == t.methodInfo);
        }
    };

    struct QueryMethodTypeOutput {
        ::rtf::maintaind::MethodDatatypeInfo methodDatatypeInfo;

        static bool IsPlane() noexcept
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun) noexcept
        {
            fun(methodDatatypeInfo);
        }

        template<typename F>
        void enumerate(F& fun) const noexcept
        {
            fun(methodDatatypeInfo);
        }

        bool operator == (const QueryMethodTypeOutput& t) const noexcept
        {
            return (methodDatatypeInfo == t.methodDatatypeInfo);
        }
    };

    struct QueryNodeInfoOutput {
        ::rtf::maintaind::VectorNodeInfo nodeInfoList;

        static bool IsPlane() noexcept
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun) noexcept
        {
            fun(nodeInfoList);
        }

        template<typename F>
        void enumerate(F& fun) const noexcept
        {
            fun(nodeInfoList);
        }

        bool operator == (const QueryNodeInfoOutput& t) const noexcept
        {
            return (nodeInfoList == t.nodeInfoList);
        }
    };

    struct QuerySubNodeEventInfoOutput {
        ::rtf::maintaind::EventInfoWithPubSub eventInfoWithSub;

        static bool IsPlane() noexcept
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun) noexcept
        {
            fun(eventInfoWithSub);
        }

        template<typename F>
        void enumerate(F& fun) const noexcept
        {
            fun(eventInfoWithSub);
        }

        bool operator == (const QuerySubNodeEventInfoOutput& t) const noexcept
        {
            return (eventInfoWithSub == t.eventInfoWithSub);
        }
    };

    struct SwitchLatencyModeOutput {
        ::rtf::maintaind::ReturnCode result;

        static bool IsPlane() noexcept
        {
            return false;
        }

        using IsEnumerableTag = void;
        template<typename F>
        void enumerate(F& fun) noexcept
        {
            fun(result);
        }

        bool operator == (const SwitchLatencyModeOutput& t) const noexcept
        {
            return (result == t.result);
        }
    };

    explicit RTFMaintaindToolsServiceSkeleton(ara::com::InstanceIdentifier instanceId,
                           ara::com::MethodCallProcessingMode mode = ara::com::MethodCallProcessingMode::kEvent)
        : skeletonAdapter(std::make_unique<ara::com::internal::skeleton::SkeletonAdapter>(
            ::rtf::maintaind::RTFMaintaindToolsService::ServiceIdentifier, instanceId, mode)),
          QueryAllDataTypeHandle(skeletonAdapter->GetSkeleton(), methods::QueryAllDataTypeId),
          QueryDataTypeHandle(skeletonAdapter->GetSkeleton(), methods::QueryDataTypeId),
          QueryDataTypeRefListHandle(skeletonAdapter->GetSkeleton(), methods::QueryDataTypeRefListId),
          QueryEventInfoHandle(skeletonAdapter->GetSkeleton(), methods::QueryEventInfoId),
          QueryEventShowHandle(skeletonAdapter->GetSkeleton(), methods::QueryEventShowId),
          QueryLatencyResultHandle(skeletonAdapter->GetSkeleton(), methods::QueryLatencyResultId),
          QueryLatencyStatusHandle(skeletonAdapter->GetSkeleton(), methods::QueryLatencyStatusId),
          QueryMethodInfoHandle(skeletonAdapter->GetSkeleton(), methods::QueryMethodInfoId),
          QueryMethodTypeHandle(skeletonAdapter->GetSkeleton(), methods::QueryMethodTypeId),
          QueryNodeInfoHandle(skeletonAdapter->GetSkeleton(), methods::QueryNodeInfoId),
          QuerySubNodeEventInfoHandle(skeletonAdapter->GetSkeleton(), methods::QuerySubNodeEventInfoId),
          SwitchLatencyModeHandle(skeletonAdapter->GetSkeleton(), methods::SwitchLatencyModeId){
        ConstructSkeleton(mode);
    }

    RTFMaintaindToolsServiceSkeleton(const RTFMaintaindToolsServiceSkeleton&) = delete;
    RTFMaintaindToolsServiceSkeleton& operator=(const RTFMaintaindToolsServiceSkeleton&) = delete;

    RTFMaintaindToolsServiceSkeleton(RTFMaintaindToolsServiceSkeleton&& other) = default;
    RTFMaintaindToolsServiceSkeleton& operator=(RTFMaintaindToolsServiceSkeleton&& other) = default;

    virtual ~RTFMaintaindToolsServiceSkeleton()
    {
        StopOfferService();
    }

    void OfferService()
    {
        skeletonAdapter->RegisterMethod(&RTFMaintaindToolsServiceSkeleton::QueryAllDataType, *this,
            methods::QueryAllDataTypeId);
        skeletonAdapter->RegisterMethod(&RTFMaintaindToolsServiceSkeleton::QueryDataType, *this,
            methods::QueryDataTypeId);
        skeletonAdapter->RegisterMethod(&RTFMaintaindToolsServiceSkeleton::QueryDataTypeRefList, *this,
            methods::QueryDataTypeRefListId);
        skeletonAdapter->RegisterMethod(&RTFMaintaindToolsServiceSkeleton::QueryEventInfo, *this,
            methods::QueryEventInfoId);
        skeletonAdapter->RegisterMethod(&RTFMaintaindToolsServiceSkeleton::QueryEventShow, *this,
            methods::QueryEventShowId);
        skeletonAdapter->RegisterMethod(&RTFMaintaindToolsServiceSkeleton::QueryLatencyResult, *this,
            methods::QueryLatencyResultId);
        skeletonAdapter->RegisterMethod(&RTFMaintaindToolsServiceSkeleton::QueryLatencyStatus, *this,
            methods::QueryLatencyStatusId);
        skeletonAdapter->RegisterMethod(&RTFMaintaindToolsServiceSkeleton::QueryMethodInfo, *this,
            methods::QueryMethodInfoId);
        skeletonAdapter->RegisterMethod(&RTFMaintaindToolsServiceSkeleton::QueryMethodType, *this,
            methods::QueryMethodTypeId);
        skeletonAdapter->RegisterMethod(&RTFMaintaindToolsServiceSkeleton::QueryNodeInfo, *this,
            methods::QueryNodeInfoId);
        skeletonAdapter->RegisterMethod(&RTFMaintaindToolsServiceSkeleton::QuerySubNodeEventInfo, *this,
            methods::QuerySubNodeEventInfoId);
        skeletonAdapter->RegisterMethod(&RTFMaintaindToolsServiceSkeleton::SwitchLatencyMode, *this,
            methods::SwitchLatencyModeId);
        skeletonAdapter->OfferService();
    }
    void StopOfferService()
    {
        skeletonAdapter->StopOfferService();
    }
    ara::core::Future<bool> ProcessNextMethodCall()
    {
        return skeletonAdapter->ProcessNextMethodCall();
    }
    bool SetMethodThreadNumber(const std::uint16_t& number, const std::uint16_t& queueSize)
    {
        return skeletonAdapter->SetMethodThreadNumber(number, queueSize);
    }
    virtual ara::core::Future<QueryAllDataTypeOutput> QueryAllDataType() = 0;
    virtual ara::core::Future<QueryDataTypeOutput> QueryDataType(const ::rtf::stdtype::String& msgName) = 0;
    virtual ara::core::Future<QueryDataTypeRefListOutput> QueryDataTypeRefList() = 0;
    virtual ara::core::Future<QueryEventInfoOutput> QueryEventInfo(const ::rtf::stdtype::String& eventName) = 0;
    virtual ara::core::Future<QueryEventShowOutput> QueryEventShow(const ::rtf::stdtype::String& eventName) = 0;
    virtual ara::core::Future<QueryLatencyResultOutput> QueryLatencyResult(
        const ::rtf::maintaind::LatencyQueryInfo& latencyQueryInfo)
    {
        ara::core::Future<QueryLatencyResultOutput> output;
        return output;
    }
    virtual ara::core::Future<QueryLatencyStatusOutput> QueryLatencyStatus(
        const ::rtf::maintaind::LatencyIndex& eventName)
    {
        ara::core::Future<QueryLatencyStatusOutput> output;
        return output;
    }
    virtual ara::core::Future<QueryMethodInfoOutput> QueryMethodInfo(const ::rtf::stdtype::String& methodName) = 0;
    virtual ara::core::Future<QueryMethodTypeOutput> QueryMethodType(const ::rtf::stdtype::String& methodName) = 0;
    virtual ara::core::Future<QueryNodeInfoOutput> QueryNodeInfo(const ::rtf::stdtype::String& appName) = 0;
    virtual ara::core::Future<QuerySubNodeEventInfoOutput> QuerySubNodeEventInfo(
        const ::rtf::maintaind::QuerySubEventInfoIndex& querySubEventInfoIndex) = 0;
    virtual ara::core::Future<SwitchLatencyModeOutput> SwitchLatencyMode(
        const ::rtf::maintaind::LatencySwitch& latencySwitch)
    {
        ara::core::Future<SwitchLatencyModeOutput> output;
        return output;
    }

    methods::QueryAllDataTypeHandle QueryAllDataTypeHandle;
    methods::QueryDataTypeHandle QueryDataTypeHandle;
    methods::QueryDataTypeRefListHandle QueryDataTypeRefListHandle;
    methods::QueryEventInfoHandle QueryEventInfoHandle;
    methods::QueryEventShowHandle QueryEventShowHandle;
    methods::QueryLatencyResultHandle QueryLatencyResultHandle;
    methods::QueryLatencyStatusHandle QueryLatencyStatusHandle;
    methods::QueryMethodInfoHandle QueryMethodInfoHandle;
    methods::QueryMethodTypeHandle QueryMethodTypeHandle;
    methods::QueryNodeInfoHandle QueryNodeInfoHandle;
    methods::QuerySubNodeEventInfoHandle QuerySubNodeEventInfoHandle;
    methods::SwitchLatencyModeHandle SwitchLatencyModeHandle;
};
} // namespace skeleton
} // namespace maintaind
} // namespace rtf
#endif // RTF_MAINTAIND_RTFMAINTAINDTOOLSSERVICE_SKELETON_H
