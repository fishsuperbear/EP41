/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2020-2021. All rights reserved.
 * Generated by VRTF CM-Generator
 */

#ifndef RTF_MAINTAIND_IMPL_TYPE_NODECOMMONREGISTERINFO_H
#define RTF_MAINTAIND_IMPL_TYPE_NODECOMMONREGISTERINFO_H
#include "rtf/stdtype/impl_type_int32_t.h"
#include "rtf/stdtype/impl_type_string.h"
#include "rtf/maintaind/impl_type_registerinfotype.h"
#include "rtf/maintaind/impl_type_nodepidinfo.h"
#include "rtf/maintaind/e2e/impl_type_appe2econfiginfo.h"

namespace rtf {
namespace maintaind {
struct NodeCommonRegisterInfo {
    ::rtf::stdtype::int32_t nodePid;
    ::rtf::stdtype::String appName;
    ::rtf::maintaind::RegisterInfoType registerInfoType;
    ::rtf::maintaind::NodePidInfo nodePidInfo;
    ::rtf::maintaind::AppE2EConfigInfo appE2EConfig;

    static bool IsPlane() noexcept
    {
        return false;
    }

    using IsEnumerableTag = void;
    template<typename F>
    void enumerate(F& fun) noexcept
    {
        fun(nodePid);
        fun(appName);
        fun(registerInfoType);
        fun(nodePidInfo);
        fun(appE2EConfig);
    }

    template<typename F>
    void enumerate(F& fun) const noexcept
    {
        fun(nodePid);
        fun(appName);
        fun(registerInfoType);
        fun(nodePidInfo);
        fun(appE2EConfig);
    }

    bool operator == (const ::rtf::maintaind::NodeCommonRegisterInfo& t) const noexcept
    {
        return (nodePid == t.nodePid) && (appName == t.appName) && (registerInfoType == t.registerInfoType) &&
               (nodePidInfo == t.nodePidInfo)  && (appE2EConfig == t.appE2EConfig);
    }
};
} // namespace maintaind
} // namespace rtf


#endif // RTF_MAINTAIND_IMPL_TYPE_NODECOMMONREGISTERINFO_H
