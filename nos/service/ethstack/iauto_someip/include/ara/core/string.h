/**
 * * --------------------------------------------------------------------
 * * |                                                                  |
 * * |     _         _    _ _______ ____         _____ ____  __  __     |
 * * |    (_)   /\  | |  | |__   __/ __ \       / ____/ __ \|  \/  |    |
 * * |     _   /  \ | |  | |  | | | |  | |     | |   | |  | | \  / |    |
 * * |    | | / /\ \| |  | |  | | | |  | |     | |   | |  | | |\/| |    |
 * * |    | |/ ____ \ |__| |  | | | |__| |  _  | |___| |__| | |  | |    |
 * * |    |_/_/    \_\____/   |_|  \____/  (_)  \_____\____/|_|  |_|    |
 * * |                                                                  |
 * * --------------------------------------------------------------------
 *
 *  * Copyright @ 2020 iAuto (Shanghai) Co., Ltd.
 *  * All Rights Reserved.
 *  *
 *  * Redistribution and use in source and binary forms, with or without
 *  * modification, are NOT permitted except as agreed by
 *  * iAuto (Shanghai) Co., Ltd.
 *  *
 *  * Unless required by applicable law or agreed to in writing, software
 *  * distributed under the License is distributed on an "AS IS" BASIS,
 *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 *
 * @file string.h
 * @brief
 * @date 2020-05-07
 *
 */

#ifndef __cplusplus
#error ERROR: This file requires C++ compilation (use a .cpp suffix)
#endif

#ifndef APD_ARA_CORE_STRING_H_
#define APD_ARA_CORE_STRING_H_

#include <functional>
#include <string>
#include <type_traits>

#include "ara/core/string_view.h"

namespace ara {
namespace core {
inline namespace _19_11 {

/**
 * @class BasicString
 *
 * @brief Class for BasicString @uptrace{SWS_CORE_03000}
 */
template <typename CharT, typename Traits = std::char_traits<CharT>,
          typename Allocator = std::allocator<CharT>>
class BasicString : public std::basic_string<CharT, Traits, Allocator> {
   public:
    using Base = std::basic_string<CharT, Traits, Allocator>;

    // Inherit most constructors of std::string
    // (except for copy/move and default ctor, see C++11, 12.9.3)
    using Base::Base;

   public:
    // Default constructors are not inherited by a using declaration, and since we
    // are
    // also adding other constructors, no default one is being generated by the
    // compiler.
    // Thus, we must define this explicitly.
    /**
     * @brief Construct a new Basic String
     */
    BasicString() noexcept( noexcept( Allocator() ) ) : Base( Allocator() ) {}

    // Single-argument copy/move constructors are not inherited by a using
    // declaration,
    // but we want them for interoperability with std::string, so that we can
    // support
    // assignment from std::string.
    /**
     * @brief Construct a new Basic String object
     *
     * @param s another basic_string instance
     */
    BasicString( Base const &s ) : Base( s ) {}

    /**
     * @brief Construct a new Basic String object
     *
     * @param s another basic_string instance
     */
    BasicString( Base &&s ) noexcept : Base( std::move( s ) ) {}

    // Standard copy and move constructors.
    /**
     * @brief Construct a new Basic String
     *
     * @param s another BasicString instance
     */
    BasicString( BasicString const &s ) : Base( s ) {}

    /**
     * @brief Construct a new Basic String
     *
     * @param s another BasicString instance
     */
    BasicString( BasicString &&s ) noexcept : Base( std::move( s ) ) {}

    // Inherit assignment operators from std::string. As this subclass does not
    // add any additional
    // data member, there is no danger of slicing.
    using Base::operator=;

    // Standard copy and move assignment operators.
    /**
     * @brief assignment function
     *
     * @param other BasicString instance
     * @return BasicString&
     */
    BasicString &operator=( BasicString const &other ) {
        assign( other );
        return *this;
    }

    /**
     * @brief assignment function
     *
     * @param other BasicString instance
     * @return BasicString&
     */
    BasicString &operator=( BasicString &&other ) {
        assign( std::move( other ) );
        return *this;
    }

    //
    // Interoperability with StringView (taken from C++17)
    //

    using size_type      = typename Base::size_type;
    using const_iterator = typename Base::const_iterator;
    using Base::npos;

    // @uptrace{SWS_CORE_03302}
    /**
     * @brief Construct a new Basic String
     *
     * @param sv another basic_string_view object
     * @param a allocator object
     */
    explicit BasicString( sv_internal::basic_string_view<CharT, Traits> sv,
                          Allocator const &                             a = Allocator() )
        : Base( sv.data(), sv.size(), a ) {}

    // @uptrace{SWS_CORE_03303}
    /**
     * @brief Construct a new Basic String
     *
     * @tparam T the type of value
     * @param t pointer to an array of characters
     * @param pos position of the first character in str that is copied to the object as substring
     * @param n number of characters to copy
     * @param a allocator object
     */
    template <typename T>
    BasicString( T const &t, size_type pos, size_type n, Allocator const &a = Allocator() )
        : BasicString( StringView( t ).substr( pos, n ), a ) {}

    // @uptrace{SWS_CORE_03304}
    /**
     * @brief string assignment
     *
     * @param sv another string object
     * @return BasicString& *this
     */
    BasicString &operator=( sv_internal::basic_string_view<CharT, Traits> sv ) {
        return assign( sv );
    }

    // @uptrace{SWS_CORE_03307}
    /**
     * @brief Concatenate strings
     *
     * @param sv another string object
     * @return BasicString& *this
     */
    BasicString &operator+=( sv_internal::basic_string_view<CharT, Traits> sv ) {
        return append( sv );
    }

    using Base::append;

    // @uptrace{SWS_CORE_03308}
    /**
     * @brief append to string
     *
     * @param sv another string object
     * @return BasicString& *this
     */
    BasicString &append( sv_internal::basic_string_view<CharT, Traits> sv ) {
        Base::append( sv.data(), sv.size() );
        return *this;
    }

    // @uptrace{SWS_CORE_03309}
    /**
     * @brief append to string
     *
     * @tparam T type of value
     * @tparam std::enable_if<
     * std::is_convertible<T const &, sv_internal::basic_string_view<CharT, Traits>>::value &&
     * !std::is_convertible<T const &, CharT const *>::value>::type
     * @param t pointer to an array of characters
     * @param pos position of the first character in str that is copied to the object as substring
     * @param n number of characters to copy
     * @return BasicString& *this
     */
    template <
        typename T,
        typename = typename std::enable_if<
            std::is_convertible<T const &, sv_internal::basic_string_view<CharT, Traits>>::value &&
            !std::is_convertible<T const &, CharT const *>::value>::type>
    BasicString &append( T const &t, size_type pos, size_type n = npos ) {
        // out_of_range if pos > sv.size() not considered
        sv_internal::basic_string_view<CharT, Traits> const sv = t;
        size_type const rlen = std::min( n, size_type( sv.size() - pos ) );
        Base::append( sv.data() + pos, rlen );
        return *this;
    }

    using Base::assign;

    // @uptrace{SWS_CORE_03305}
    /**
     * @brief assign content to string
     *
     * @param sv another string object
     * @return BasicString& *this
     */
    BasicString &assign( sv_internal::basic_string_view<CharT, Traits> sv ) {
        Base::assign( sv.data(), sv.size() );
        return *this;
    }

    // @uptrace{SWS_CORE_03306}
    /**
     * @brief assign content to string
     *
     * @tparam T type of value
     * @tparam std::enable_if<
     * std::is_convertible<T const &, sv_internal::basic_string_view<CharT, Traits>>::value &&
     * !std::is_convertible<T const &, CharT const *>::value>::type
     * @param t pointer to an array of characters
     * @param pos position of the first character in str that is copied to the object as substring
     * @param n number of characters to copy
     * @return BasicString& *this
     */
    template <
        typename T,
        typename = typename std::enable_if<
            std::is_convertible<T const &, sv_internal::basic_string_view<CharT, Traits>>::value &&
            !std::is_convertible<T const &, CharT const *>::value>::type>
    BasicString &assign( T const &t, size_type pos, size_type n = npos ) {
        // Out_of_range if pos > sv.size() not considered
        sv_internal::basic_string_view<CharT, Traits> const sv = t;
        size_type const rlen = std::min( n, size_type( Base::size() - pos ) );
        Base::assign( sv.data() + pos, rlen );
        return *this;
    }

    using Base::insert;

    // @uptrace{SWS_CORE_03310}
    /**
     * @brief insert into string
     *
     * @param pos insertion point
     * @param sv another string object
     * @return BasicString& *this
     */
    BasicString &insert( size_type pos, sv_internal::basic_string_view<CharT, Traits> sv ) {
        Base::insert( pos, sv.data(), sv.size() );
        return *this;
    }

    // @uptrace{SWS_CORE_03311}
    /**
     * @brief insert into string
     *
     * @tparam T type of value
     * @tparam std::enable_if<
     * std::is_convertible<T const &, sv_internal::basic_string_view<CharT, Traits>>::value &&
     * !std::is_convertible<T const &, CharT const *>::value>::type
     * @param pos1 insertion point
     * @param t pointer to an array of characters
     * @param pos2 the substring of position
     * @param n number of characters to copy
     * @return BasicString& *this
     */
    template <
        typename T,
        typename = typename std::enable_if<
            std::is_convertible<T const &, sv_internal::basic_string_view<CharT, Traits>>::value &&
            !std::is_convertible<T const &, CharT const *>::value>::type>
    BasicString &insert( size_type pos1, T const &t, size_type pos2, size_type n = npos ) {
        // Out_of_range if pos1 > size() or pos2 > sv.size() not considered
        sv_internal::basic_string_view<CharT, Traits> sv = t;
        size_type const rlen = std::min( n, size_type( Base::size() - pos2 ) );
        Base::insert( pos1, sv.data() + pos2, rlen );
        return *this;
    }

    using Base::replace;

    // @uptrace{SWS_CORE_03312}
    /**
     * @brief replace portion of string
     *
     * @param pos1 position of the first character ot be replaced.
     * @param n1 number of characters to replace.
     * @param sv another string object
     * @return BasicString& *this
     */
    BasicString &replace( size_type pos1, size_type n1,
                          sv_internal::basic_string_view<CharT, Traits> sv ) {
        Base::replace( pos1, n1, sv.data(), sv.size() );
        return *this;
    }

    // @uptrace{SWS_CORE_03313}
    /**
     * @brief replace portion of string
     *
     * @tparam T type of value
     * @tparam std::enable_if<
     * std::is_convertible<T const &, sv_internal::basic_string_view<CharT, Traits>>::value &&
     * !std::is_convertible<T const &, CharT const *>::value>::type
     * @param pos1 position of the first character ot be replaced.
     * @param n1 number of characters to replace.
     * @param t pointer to an array of characters
     * @param pos2 the substring of position
     * @param n2 number of characters
     * @return BasicString& *this
     */
    template <
        typename T,
        typename = typename std::enable_if<
            std::is_convertible<T const &, sv_internal::basic_string_view<CharT, Traits>>::value &&
            !std::is_convertible<T const &, CharT const *>::value>::type>
    BasicString &replace( size_type pos1, size_type n1, T const &t, size_type pos2,
                          size_type n2 = npos ) {
        // Out_of_range if pos1 > size() or pos2 > sv.size() not considered
        sv_internal::basic_string_view<CharT, Traits> sv = t;
        size_type const rlen = std::min( n2, size_type( sv.size() - pos2 ) );
        Base::replace( pos1, n1, sv.data() + pos2, rlen );
        return *this;
    }

    // @uptrace{SWS_CORE_03314}
    /**
     * @brief replace portion of string
     *
     * @param i1 an initializer_list object
     * @param i2 an initializer_list object
     * @param sv another string object
     * @return BasicString& *this
     */
    BasicString &replace( const_iterator i1, const_iterator i2,
                          sv_internal::basic_string_view<CharT, Traits> sv ) {
        return replace( i1 - Base::begin(), i2 - i1, sv );
    }

    // @uptrace{SWS_CORE_03301}
    /**
     * @brief create stringview
     *
     * @return sv_internal::basic_string_view<CharT, Traits> the new stringview
     */
    operator sv_internal::basic_string_view<CharT, Traits>() const noexcept {
        return StringView( Base::data(), Base::size() );
    }

    using Base::find;
    using Base::find_first_not_of;
    using Base::find_first_of;
    using Base::find_last_not_of;
    using Base::find_last_of;
    using Base::rfind;

    // @uptrace{SWS_CORE_03315}
    /**
     * @brief find first occurrence in string
     *
     * @param sv another string with the subject to search for.
     * @param pos position of the first character in the string to be considered in the search.
     * @return size_type the position of the first character of the first match.
     */
    size_type find( sv_internal::basic_string_view<CharT, Traits> sv,
                    size_type                                     pos = 0 ) const noexcept {
        return Base::find( sv.data(), pos, sv.size() );
    }

    // @uptrace{SWS_CORE_03316}
    /**
     * @brief find last occurrence in string
     *
     * @param sv another string with the subject to search for.
     * @param pos position of the first character in the string to be considered in the search.
     * @return size_type the position of the first character of the first match.
     */
    size_type rfind( sv_internal::basic_string_view<CharT, Traits> sv,
                     size_type                                     pos = npos ) const noexcept {
        return Base::rfind( sv.data(), pos, sv.size() );
    }

    // @uptrace{SWS_CORE_03317}
    /**
     * @brief find character in string
     *
     * @param sv another string with the subject to search for.
     * @param pos position of the first character in the string to be considered in the search.
     * @return size_type the position of the first character of the first match.
     */
    size_type find_first_of( sv_internal::basic_string_view<CharT, Traits> sv,
                             size_type pos = 0 ) const noexcept {
        return Base::find_first_of( sv.data(), pos, sv.size() );
    }

    // @uptrace{SWS_CORE_03318}
    /**
     * @brief find character in string from the end
     *
     * @param sv another string with the subject to search for.
     * @param pos position of the first character in the string to be considered in the search.
     * @return size_type the position of the first character of the first match.
     */
    size_type find_last_of( sv_internal::basic_string_view<CharT, Traits> sv,
                            size_type pos = npos ) const noexcept {
        return Base::find_last_of( sv.data(), pos, sv.size() );
    }

    // @uptrace{SWS_CORE_03319}
    /**
     * @brief find non-matching character in string
     *
     * @param sv another string with the subject to search for.
     * @param pos position of the first character in the string to be considered in the search.
     * @return size_type the position of the first character of the first match.
     */
    size_type find_first_not_of( sv_internal::basic_string_view<CharT, Traits> sv,
                                 size_type pos = 0 ) const noexcept {
        return Base::find_first_not_of( sv.data(), pos, sv.size() );
    }

    // @uptrace{SWS_CORE_03320}
    /**
     * @brief find non-matching character in string from the end
     *
     * @param sv another string with the subject to search for.
     * @param pos position of the first character in the string to be considered in the search.
     * @return size_type the position of the first character of the first match.
     */
    size_type find_last_not_of( sv_internal::basic_string_view<CharT, Traits> sv,
                                size_type pos = npos ) const noexcept {
        return Base::find_last_not_of( sv.data(), pos, sv.size() );
    }

    using Base::compare;

    // @uptrace{SWS_CORE_03321}
    /**
     * @brief compare strings
     *
     * @param sv another string with the subject to search for.
     * @return int 0:they compare equal
     *            <0:either the value of the first character
     *               that does not match is lower in the  compared string,
     *               or all compared characters match but the compared string is shorter.
     *            >0:either the value of the first character
     *               that does not match is greater in the compared string,
     *               or all compared characters match but the compared string is longer.
     */
    int compare( sv_internal::basic_string_view<CharT, Traits> sv ) const noexcept {
        size_type const rlen = std::min( Base::size(), sv.size() );
        int const       ret  = Traits::compare( Base::data(), sv.data(), rlen );
        if ( ret == 0 ) {
            return ( Base::size() < sv.size() ) ? -1 : Base::size() > sv.size();
        }
        return ret;
    }

    // @uptrace{SWS_CORE_03322}
    /**
     * @brief compare strings
     *
     * @param pos1 position of the first character in the compared string
     * @param n1 length of compared string
     * @param sv another string object, used entirely as the comparing string.
     * @return int 0:they compare equal
     *            <0:either the value of the first character
     *               that does not match is lower in the  compared string,
     *               or all compared characters match but the compared string is shorter.
     *            >0:either the value of the first character
     *               that does not match is greater in the compared string,
     *               or all compared characters match but the compared string is longer.
     */
    int compare( size_type pos1, size_type n1,
                 sv_internal::basic_string_view<CharT, Traits> sv ) const {
        return sv_internal::basic_string_view<CharT, Traits>( Base::data(), Base::size() )
            .substr( pos1, n1 )
            .compare( sv );
    }

    // @uptrace{SWS_CORE_03323}
    /**
     * @brief compare strings
     *
     * @tparam T
     * @tparam std::enable_if<
     * std::is_convertible<T const &, sv_internal::basic_string_view<CharT, Traits>>::value &&
     * !std::is_convertible<T const &, CharT const *>::value>::type
     * @param pos1 position of the first character ot be replaced.
     * @param n1 number of characters to replace.
     * @param t pointer to an array of characters
     * @param pos2 the substring of position
     * @param n2 number of characters
     * @return int 0:they compare equal
     *            <0:either the value of the first character
     *               that does not match is lower in the  compared string,
     *               or all compared characters match but the compared string is shorter.
     *            >0:either the value of the first character
     *               that does not match is greater in the compared string,
     *               or all compared characters match but the compared string is longer.
     */
    template <
        typename T,
        typename = typename std::enable_if<
            std::is_convertible<T const &, sv_internal::basic_string_view<CharT, Traits>>::value &&
            !std::is_convertible<T const &, CharT const *>::value>::type>
    int compare( size_type pos1, size_type n1, T const &t, size_type pos2,
                 size_type n2 = npos ) const {
        sv_internal::basic_string_view<CharT, Traits> const sv = t;
        return sv_internal::basic_string_view<CharT, Traits>( Base::data(), Base::size() )
            .substr( pos1, n1 )
            .compare( sv.substr( pos2, n2 ) );
    }
};

/**
 * @brief Representation of a contiguous sequence of narrow characters
 *
 * @uptrace{SWS_CORE_03001}
 */
using String = BasicString<char>;

// Transitional compatibility name; should remove this before R18-10.
using string = std::basic_string<char>;

// @uptrace{SWS_CORE_03296}
/**
 * @brief Add overload of std::swap for String.
 *
 * @tparam Dummy void type
 * @tparam std::enable_if<
 * !std::is_same<String, std::string>::value, Dummy>::type
 * @param lhs the first argument of the swap invocation
 * @param rhs the second argument of the swap invocation
 */
template <typename Dummy = void, typename = typename std::enable_if<
                                     !std::is_same<String, std::string>::value, Dummy>::type>
void swap( String &lhs, String &rhs ) {
    lhs.swap( rhs );
}
}  // namespace _19_11
}  // namespace core
}  // namespace ara

namespace std {

// @brief Specialization of std::hash for ara::core::String
template <>
struct hash<ara::core::String> {
    using result_type = std::size_t;

    /**
     * @brief Function call operator to retrieve the hash value of ara::core::String.
     *
     * @param s the ara::core::String to be hashed.
     * @return result_type the hash value
     */
    result_type operator()( ara::core::String const &s ) const noexcept {
        using std::hash;
        result_type ret = 0;
        for ( result_type i = 0; i < s.length(); ++i ) {
            ret += hash<char>()( s[ i ] );
        }
        return ret;
    }
};

}  // namespace std

#endif  // APD_ARA_CORE_STRING_H_
/* EOF */
